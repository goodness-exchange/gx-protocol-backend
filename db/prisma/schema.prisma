// =============================================================================
// GX COIN PROTOCOL - ENHANCED PRODUCTION SCHEMA
// =============================================================================
// Version: 2.0 (Enhanced)
// Date: October 16, 2025
// 
// This schema incorporates:
// - Multi-tenancy across all tables
// - CQRS/Event-Driven Architecture
// - Trust Score & Family Relationship Tree (80 points)
// - Business Account Governance & Multi-Signature
// - Comprehensive Audit Trail
// - Session & Device Management
// - Notification System
// - Enhanced KYC Document Management
// - Transaction Limits & Fraud Prevention
// - Contact Management
// - Hoarding Tax Calculation
// =============================================================================

generator client {
  provider = "prisma-client-js"
  output   = "../../packages/core-db/node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
// SECTION 1: ENUMs (Custom Data Types)
// =============================================================================

// Existing ENUMs
enum OutboxStatus {
  PENDING
  LOCKED
  SUBMITTED
  COMMITTED
  FAILED
}

enum CommandType {
  // IdentityContract
  CREATE_USER

  // TokenomicsContract
  TRANSFER_TOKENS
  DISTRIBUTE_GENESIS
  FREEZE_WALLET
  UNFREEZE_WALLET

  // OrganizationContract
  PROPOSE_ORGANIZATION
  ENDORSE_MEMBERSHIP
  ACTIVATE_ORGANIZATION
  DEFINE_AUTH_RULE
  INITIATE_MULTISIG_TX
  APPROVE_MULTISIG_TX
  EXECUTE_MULTISIG_TX

  // LoanPoolContract
  APPLY_FOR_LOAN
  APPROVE_LOAN

  // GovernanceContract
  SUBMIT_PROPOSAL
  CAST_VOTE
  EXECUTE_PROPOSAL

  // AdminContract
  BOOTSTRAP_SYSTEM
  INITIALIZE_COUNTRY_DATA
  UPDATE_SYSTEM_PARAMETER
  PAUSE_SYSTEM
  RESUME_SYSTEM
  APPOINT_ADMIN
  ACTIVATE_TREASURY

  // TaxAndFeeContract
  APPLY_VELOCITY_TAX
}

enum UserProfileStatus {
  REGISTERED
  PENDING_ADMIN_APPROVAL
  APPROVED_PENDING_ONCHAIN
  DENIED
  ACTIVE
  FROZEN
  SUSPENDED
  CLOSED
}

enum KycStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

enum OrgProfileStatus {
  PENDING_VERIFICATION
  VERIFIED
  REJECTED
  SUSPENDED
}

enum PartnerStatus {
  PENDING
  ACTIVE
  REVOKED
}

enum LicenseStatus {
  ACTIVE
  EXPIRED
  REVOKED
}

enum CredentialStatus {
  ACTIVE
  REVOKED
}

enum LegalTenderStatusEnum {
  RECOGNIZED
  SANDBOX
  ACTIVE_LEGAL_TENDER
}

enum OffChainTxType {
  // Core token operations
  MINT                      // System minting new tokens
  GENESIS                   // Initial token allocation

  // P2P transfers
  SENT                      // Outgoing transfer
  RECEIVED                  // Incoming transfer

  // Fees & taxes
  FEE                       // Transaction fees
  TAX                       // Tax deductions (velocity tax, hoarding tax)
  TAX_REFUND                // Tax refund/correction

  // Loans
  LOAN_DISBURSEMENT         // Loan funds received
  LOAN_REPAYMENT            // Loan payment made

  // Donations & grants
  DONATION                  // Charitable donation
  GRANT                     // Grant received

  // Organization/multi-sig
  ORG_DEPOSIT               // Deposit to organization
  ORG_WITHDRAWAL            // Withdrawal from organization
  ORG_DIVIDEND              // Dividend/distribution from org

  // Escrow & holds
  ESCROW_LOCK               // Funds locked in escrow
  ESCROW_RELEASE            // Funds released from escrow
  HOLD                      // Temporary hold on funds
  HOLD_RELEASE              // Hold released

  // Rewards & incentives
  REWARD                    // System reward/incentive
  REFERRAL_BONUS            // Referral program bonus
  STAKING_REWARD            // Staking rewards

  // Corrections & adjustments
  ADJUSTMENT                // Manual adjustment by admin
  REVERSAL                  // Transaction reversal
  REFUND                    // Refund issued
}

enum CollateralStatus {
  PLEDGED
  RELEASED
}

// Registration Step Tracking (Progressive Registration Flow)
enum RegistrationStep {
  EMAIL_PENDING // Initial state
  EMAIL_SENT // OTP sent to email
  EMAIL_VERIFIED // Email OTP verified
  NAME_COUNTRY_SET // First name, last name, country collected
  DOB_GENDER_SET // Date of birth and gender collected
  PASSWORD_SET // Password created
  PHONE_SENT // OTP sent to phone
  PHONE_VERIFIED // Phone OTP verified - registration complete
  COMPLETED // Migrated to UserProfile
}

// Employment Status for KYR Work/Company Details
enum EmploymentStatus {
  EMPLOYED
  SELF_EMPLOYED
  FREELANCER
  STUDENT
  RETIRED
  UNEMPLOYED
  OTHER
}

// Gender enum for user registration
enum Gender {
  MALE
  FEMALE
}

// Address Type for KYR address history
enum AddressType {
  CURRENT // Current residential address
  PREVIOUS // Previous address (kept for history)
  MAILING // Mailing address if different
  WORK // Work address
}

// NEW ENUMs for Enhanced Features
enum RelationType {
  FATHER
  MOTHER
  SPOUSE
  CHILD
  SIBLING
  BUSINESS_PARTNER
  DIRECTOR
  WORKPLACE_ASSOCIATE
  FRIEND
}

enum RelationshipStatus {
  PENDING // Invitation sent, awaiting confirmation
  CONFIRMED // Both parties confirmed
  REJECTED // Rejected by invitee
  DECEASED // Marked deceased with documentation
  DIVORCED // Marked divorced with documentation
  NOT_APPLICABLE // User indicated N/A (triggers re-weighting)
}

enum SignatoryRole {
  OWNER
  DIRECTOR
  AUTHORIZED_SIGNATORY
  ACCOUNTANT
  VIEWER
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

enum AuditEventType {
  USER_LOGIN
  USER_LOGOUT
  USER_REGISTERED
  PROFILE_UPDATED
  PASSWORD_CHANGED
  KYC_SUBMITTED
  KYC_APPROVED
  KYC_REJECTED
  TRANSACTION_INITIATED
  TRANSACTION_APPROVED
  TRANSACTION_REJECTED
  TRANSACTION_COMPLETED
  TRANSACTION_FAILED
  WALLET_CREATED
  BENEFICIARY_ADDED
  BENEFICIARY_REMOVED
  RELATIONSHIP_INVITED
  RELATIONSHIP_CONFIRMED
  RELATIONSHIP_REJECTED
  BUSINESS_SIGNATORY_ADDED
  BUSINESS_SIGNATORY_REVOKED
  ADMIN_ACCOUNT_FROZEN
  ADMIN_ACCOUNT_UNFROZEN
  ADMIN_ACCOUNT_CLOSED
  SESSION_CREATED
  SESSION_REVOKED
  DEVICE_TRUSTED
  DEVICE_UNTRUSTED
}

enum SessionStatus {
  ACTIVE
  EXPIRED
  REVOKED
  LOGGED_OUT
}

enum NotificationType {
  RELATIONSHIP_INVITATION
  RELATIONSHIP_CONFIRMED
  RELATIONSHIP_REJECTED
  BUSINESS_SIGNATORY_INVITATION
  TRANSACTION_APPROVAL_REQUEST
  TRANSACTION_APPROVED
  TRANSACTION_REJECTED
  TRANSACTION_COMPLETED
  KYC_STATUS_UPDATE
  WALLET_CREDITED
  WALLET_DEBITED
  SYSTEM_ANNOUNCEMENT
  SECURITY_ALERT
}

enum NotificationStatus {
  UNREAD
  READ
  ARCHIVED
  ACTIONED
}

enum DocumentType {
  NATIONAL_ID
  PASSPORT
  DRIVERS_LICENSE
  PROOF_OF_ADDRESS
  DEATH_CERTIFICATE
  DIVORCE_CERTIFICATE
  BUSINESS_REGISTRATION
  TAX_REGISTRATION
  BANK_STATEMENT
  UTILITY_BILL
  SELFIE_PHOTO
  OTHER
}

enum LimitType {
  DAILY_SEND
  DAILY_RECEIVE
  MONTHLY_SEND
  MONTHLY_RECEIVE
  SINGLE_TRANSACTION
  VELOCITY_CHECK
}

enum ContactStatus {
  ACTIVE
  BLOCKED
  ARCHIVED
}

// =============================================================================
// SECTION 2: PROGRESSIVE REGISTRATION (Pre-UserProfile)
// =============================================================================

/// PendingRegistration: Stores progressive registration data before migration to UserProfile.
/// This implements a Wise.com-style registration flow where each step saves to the database.
/// Upon completing phone verification, the data is migrated to UserProfile and this record is
/// marked as COMPLETED (or optionally deleted after a retention period).
///
/// Test OTP: During development/testing, use "111111" as the OTP code for both email and phone.
/// This allows testing the full registration flow without a real SMS/email provider.
model PendingRegistration {
  id       String @id @default(uuid())
  tenantId String @default("default")

  // Step 1 & 2: Email verification
  email             String    @unique
  emailOtpHash      String? // bcrypt hash of OTP
  emailOtpExpiresAt DateTime? @db.Timestamptz(3)
  emailOtpAttempts  Int       @default(0) // Rate limiting: max 5 attempts
  emailVerified     Boolean   @default(false)
  emailVerifiedAt   DateTime? @db.Timestamptz(3)

  // Step 3: Name & Country
  firstName   String?
  lastName    String?
  countryCode String? @db.Char(2) // ISO 3166-1 alpha-2

  // Step 4: DOB & Gender (required for Fabric User ID generation and genesis eligibility)
  dateOfBirth DateTime? @db.Date
  gender      Gender?

  // Step 5: Password
  passwordHash String?

  // Step 6 & 7: Phone verification
  phoneNum          String?   @unique
  phoneOtpHash      String? // bcrypt hash of OTP
  phoneOtpExpiresAt DateTime? @db.Timestamptz(3)
  phoneOtpAttempts  Int       @default(0) // Rate limiting: max 5 attempts
  phoneVerified     Boolean   @default(false)
  phoneVerifiedAt   DateTime? @db.Timestamptz(3)

  // Progress tracking
  currentStep RegistrationStep @default(EMAIL_PENDING)

  // Security & Audit
  ipAddress String? // For fraud detection
  userAgent String? // Browser/device info

  // Timestamps & Expiry
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)
  expiresAt DateTime @db.Timestamptz(3) // Auto-cleanup incomplete registrations (24h)

  // Migration tracking (after successful registration)
  migratedToProfileId String?   @unique // UserProfile.profileId after completion
  migratedAt          DateTime? @db.Timestamptz(3)

  @@index([tenantId, currentStep])
  @@index([tenantId, email])
  @@index([tenantId, phoneNum])
  @@index([expiresAt]) // For cleanup job
  @@index([createdAt])
}

// =============================================================================
// SECTION 3: CORE IDENTITY & GOVERNANCE MODELS
// =============================================================================

model Country {
  countryCode          String                @id @db.Char(2)
  countryName          String
  region               String?
  legalTenderStatuses  LegalTenderStatus[]
  organizationProfiles OrganizationProfile[]
  licensedPartners     LicensedPartner[]
  kycDocuments         KYCDocument[]
  userProfiles         UserProfile[] // Users with this nationality
}

model LegalTenderStatus {
  statusId      String                @id @default(uuid())
  countryCode   String                @db.Char(2)
  status        LegalTenderStatusEnum
  effectiveDate DateTime              @db.Timestamptz(3)
  createdAt     DateTime              @default(now()) @db.Timestamptz(3)
  country       Country               @relation(fields: [countryCode], references: [countryCode])

  @@index([countryCode, effectiveDate])
}

model UserProfile {
  profileId String @id @default(uuid())
  tenantId  String

  // Basic identity (from registration)
  firstName              String
  middleName             String? // NEW: Middle name for KYR
  lastName               String
  email                  String?           @unique // Case-insensitive unique index added via migration
  phoneNum               String?           @unique
  biometricHash          String            @unique
  passwordHash           String
  dateOfBirth            DateTime?         @db.Date
  gender                 String? // "male" or "female" - required for Fabric User ID generation
  placeOfBirth           String? // NEW: City/Country of birth for KYR
  nationalityCountryCode String?           @db.Char(2) // For genesis coin distribution to national treasury
  fabricUserId           String?           @unique // Generated deterministic ID (format: CC CCC AANNNN TCCCC NNNN)
  status                 UserProfileStatus @default(REGISTERED)
  onchainStatus          String? // Mirror of blockchain User.Status

  // National ID (MANDATORY during KYR)
  nationalIdNumber    String? // National ID card number
  nationalIdIssuedAt  DateTime? @db.Date
  nationalIdExpiresAt DateTime? @db.Date

  // Passport (OPTIONAL during KYR)
  passportNumber         String?
  passportIssuingCountry String?   @db.Char(2)
  passportIssuedAt       DateTime? @db.Date
  passportExpiresAt      DateTime? @db.Date

  // Employment / Work Details (for future organization sync)
  employmentStatus EmploymentStatus?
  jobTitle         String?
  companyName      String?
  industry         String? // Dropdown from predefined list
  workEmail        String? // For organization verification
  workPhoneNum     String?

  // Compliance flags
  isPEP      Boolean @default(false) // Politically Exposed Person
  pepDetails String? // If isPEP=true, describe position

  // Account lock/freeze management
  isLocked   Boolean   @default(false)
  lockReason String?
  lockedBy   String? // Admin profileId
  lockedAt   DateTime? @db.Timestamptz(3)
  lockNotes  String?

  // Admin review tracking
  reviewedBy   String? // Admin profileId
  reviewedAt   DateTime? @db.Timestamptz(3)
  denialReason String?

  // Blockchain synchronization
  onchainRegisteredAt DateTime? @db.Timestamptz(3)
  lastSyncedAt        DateTime? @db.Timestamptz(3)

  // Soft delete support
  deletedAt DateTime? @db.Timestamptz(3)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  // Existing relations
  kycVerifications  KYCVerification[]
  wallets           Wallet[]
  beneficiaries     Beneficiary[]
  organizationLinks UserOrganizationLink[]

  // NEW: Address history
  addresses Address[]

  // NEW: Trust Score & Relationships
  trustScore             TrustScore?
  initiatedRelationships FamilyRelationship[] @relation("InitiatedRelationships")
  receivedRelationships  FamilyRelationship[] @relation("ReceivedRelationships")

  // NEW: Security & Sessions
  sessions       UserSession[]
  trustedDevices TrustedDevice[]

  // NEW: Notifications
  notifications Notification[]
  pushTokens    PushToken[]

  // NEW: Business Governance
  businessSignatories BusinessSignatory[]

  // NEW: Contact Management
  ownedContacts Contact[] @relation("OwnedContacts")
  contactedBy   Contact[] @relation("ContactedBy")

  // NEW: Transaction Limits
  transactionLimits TransactionLimit[]

  // Relations to Country
  nationalityCountry Country? @relation(fields: [nationalityCountryCode], references: [countryCode])

  @@index([tenantId, status])
  @@index([tenantId, email])
  @@index([tenantId, phoneNum])
  @@index([tenantId, deletedAt])
  @@index([tenantId, nationalityCountryCode])
  @@index([fabricUserId])
  @@index([isLocked])
  @@index([reviewedBy])
  // Unique constraint: National ID must be unique within a country
  @@unique([nationalityCountryCode, nationalIdNumber], name: "unique_national_id_per_country")
}

/// Address: Stores user address history for KYR verification.
/// Maintains history of addresses with proof documents for compliance.
model Address {
  addressId String @id @default(uuid())
  tenantId  String
  profileId String

  // Address type
  addressType AddressType @default(CURRENT)
  isCurrent   Boolean     @default(true) // Only one CURRENT per user

  // Address fields
  addressLine1  String
  addressLine2  String?
  city          String
  stateProvince String?
  postalCode    String?
  countryCode   String  @db.Char(2) // ISO 3166-1 alpha-2

  // Proof of address document (for KYR)
  proofDocumentUrl  String? // S3/storage URL
  proofDocumentHash String? // SHA-256 for integrity
  proofDocumentType String? // "utility_bill", "bank_statement", etc.
  proofUploadedAt   DateTime? @db.Timestamptz(3)

  // Verification
  isVerified Boolean   @default(false)
  verifiedAt DateTime? @db.Timestamptz(3)
  verifiedBy String? // Admin profileId

  // History tracking
  validFrom DateTime  @default(now()) @db.Timestamptz(3)
  validTo   DateTime? @db.Timestamptz(3) // null = current address

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  userProfile UserProfile @relation(fields: [profileId], references: [profileId], onDelete: Cascade)

  @@index([tenantId, profileId])
  @@index([tenantId, profileId, addressType])
  @@index([tenantId, profileId, isCurrent])
  @@index([countryCode])
}

model KYCVerification {
  kycId           String    @id @default(uuid())
  profileId       String
  status          KycStatus
  verifiedAt      DateTime? @db.Timestamptz(3)
  verifierDetails String?

  // Legacy fields (kept for backward compatibility)
  evidenceHash String? // sha256 of doc bundle
  evidenceSize Int? // bytes
  evidenceMime String?

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  userProfile UserProfile @relation(fields: [profileId], references: [profileId], onDelete: Cascade)

  // NEW: Document management
  documents KYCDocument[]

  @@index([profileId])
  @@index([status])
}

model OrganizationProfile {
  orgProfileId            String           @id @default(uuid())
  tenantId                String
  legalName               String
  registrationNumber      String?
  jurisdictionCountryCode String           @db.Char(2)
  address                 String?
  status                  OrgProfileStatus @default(PENDING_VERIFICATION)

  // Soft delete support
  deletedAt DateTime? @db.Timestamptz(3)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  country   Country                @relation(fields: [jurisdictionCountryCode], references: [countryCode])
  userLinks UserOrganizationLink[]

  // NEW: Business Account Support
  businessAccounts BusinessAccount[]

  @@index([tenantId, status])
  @@index([tenantId, deletedAt])
}

// =============================================================================
// SECTION 3: TRUST SCORE & FAMILY RELATIONSHIPS
// =============================================================================

model FamilyRelationship {
  relationshipId     String             @id @default(uuid())
  tenantId           String
  initiatorProfileId String // User who sent the invite
  relatedProfileId   String? // Target user (null if not on platform yet)
  relatedEmail       String? // For off-platform invitations
  relationType       RelationType
  status             RelationshipStatus @default(PENDING)

  // Status documentation
  statusDocumentUrl  String? // Death cert, divorce cert, etc.
  statusDocumentHash String?
  statusRemarks      String?

  // Confirmation workflow
  confirmedAt DateTime? @db.Timestamptz(3)
  rejectedAt  DateTime? @db.Timestamptz(3)

  // Trust score contribution
  pointsAwarded Int     @default(0)
  isApplicable  Boolean @default(true)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  initiator UserProfile  @relation("InitiatedRelationships", fields: [initiatorProfileId], references: [profileId], onDelete: Cascade)
  related   UserProfile? @relation("ReceivedRelationships", fields: [relatedProfileId], references: [profileId], onDelete: Cascade)

  @@unique([tenantId, initiatorProfileId, relatedProfileId, relationType])
  @@index([tenantId, initiatorProfileId])
  @@index([tenantId, relatedProfileId])
  @@index([tenantId, status])
  @@index([tenantId, relationType, status])
}

model TrustScore {
  profileId String @id
  tenantId  String

  // Score breakdown (max 100 points)
  familyScore   Int @default(0) // Max 80
  businessScore Int @default(0) // Max 10
  friendsScore  Int @default(0) // Max 10
  totalScore    Int @default(0) // Max 100

  // Weighting factors (for dynamic re-weighting when categories N/A)
  familyWeight   Decimal @default(0.80) @db.Decimal(5, 2)
  businessWeight Decimal @default(0.10) @db.Decimal(5, 2)
  friendsWeight  Decimal @default(0.10) @db.Decimal(5, 2)

  // Meta
  lastCalculatedAt   DateTime @db.Timestamptz(3)
  calculationVersion String   @default("1.0")

  userProfile UserProfile @relation(fields: [profileId], references: [profileId], onDelete: Cascade)

  @@index([tenantId, totalScore])
}

// =============================================================================
// SECTION 4: WALLET & TRANSACTIONS
// =============================================================================

model Wallet {
  walletId         String  @id @default(uuid())
  tenantId         String
  profileId        String
  primaryAccountId String
  walletName       String
  cachedBalance    Decimal @default(0) @db.Decimal(36, 9)

  // Soft delete support
  deletedAt DateTime? @db.Timestamptz(3)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  userProfile  UserProfile   @relation(fields: [profileId], references: [profileId], onDelete: Cascade)
  transactions Transaction[]

  // NEW: Business Account Support
  businessAccount BusinessAccount?

  // NEW: Hoarding Tax
  hoardingTaxSnapshots HoardingTaxSnapshot[]

  @@unique([tenantId, primaryAccountId])
  @@index([tenantId, profileId])
  @@index([tenantId, deletedAt])
}

model Transaction {
  offTxId      String         @id @default(uuid())
  tenantId     String
  onChainTxId  String?
  walletId     String
  type         OffChainTxType
  counterparty String
  amount       Decimal        @db.Decimal(36, 9)
  fee          Decimal        @default(0) @db.Decimal(36, 9)
  remark       String?
  timestamp    DateTime       @db.Timestamptz(3)
  blockNumber  BigInt?

  wallet Wallet @relation(fields: [walletId], references: [walletId], onDelete: Cascade)

  // NEW: Risk Scoring
  riskScore TransactionRiskScore?

  @@unique([tenantId, onChainTxId])
  @@index([tenantId, walletId, timestamp])
  @@index([tenantId, counterparty, timestamp])
  @@index([timestamp])
}

model Beneficiary {
  beneficiaryId         String @id @default(uuid())
  tenantId              String
  ownerProfileId        String
  beneficiaryIdentityId String
  nickname              String

  createdAt DateTime @default(now()) @db.Timestamptz(3)

  userProfile UserProfile @relation(fields: [ownerProfileId], references: [profileId], onDelete: Cascade)

  @@unique([tenantId, ownerProfileId, beneficiaryIdentityId])
  @@index([ownerProfileId])
}

model Contact {
  contactId      String @id @default(uuid())
  tenantId       String
  ownerProfileId String

  // Contact details
  contactProfileId String? // If registered on GX
  displayName      String
  phoneNumber      String?
  email            String?
  notes            String?

  // Metadata
  isFavorite        Boolean   @default(false)
  transactionCount  Int       @default(0)
  lastTransactionAt DateTime? @db.Timestamptz(3)

  status    ContactStatus @default(ACTIVE)
  createdAt DateTime      @default(now()) @db.Timestamptz(3)
  updatedAt DateTime      @updatedAt @db.Timestamptz(3)

  owner          UserProfile  @relation("OwnedContacts", fields: [ownerProfileId], references: [profileId], onDelete: Cascade)
  contactProfile UserProfile? @relation("ContactedBy", fields: [contactProfileId], references: [profileId], onDelete: SetNull)

  @@unique([tenantId, ownerProfileId, contactProfileId])
  @@index([tenantId, ownerProfileId])
  @@index([tenantId, status])
}

// =============================================================================
// SECTION 5: BUSINESS ACCOUNTS & MULTI-SIGNATURE
// =============================================================================

model BusinessAccount {
  businessAccountId String @id @default(uuid())
  tenantId          String
  orgProfileId      String // Links to OrganizationProfile
  walletId          String @unique

  // Multi-sig configuration
  defaultRequiredApprovals Int @default(1)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  organization     OrganizationProfile   @relation(fields: [orgProfileId], references: [orgProfileId], onDelete: Cascade)
  wallet           Wallet                @relation(fields: [walletId], references: [walletId])
  signatories      BusinessSignatory[]
  signatoryRules   SignatoryRule[]
  pendingApprovals TransactionApproval[]

  @@unique([tenantId, orgProfileId])
  @@index([tenantId])
}

model BusinessSignatory {
  signatoryId       String        @id @default(uuid())
  tenantId          String
  businessAccountId String
  profileId         String // UserProfile
  role              SignatoryRole

  // Permissions
  canInitiateTransactions Boolean  @default(false)
  canApproveTransactions  Boolean  @default(false)
  maxTransactionLimit     Decimal? @db.Decimal(36, 9)

  // Status
  invitedAt   DateTime  @default(now()) @db.Timestamptz(3)
  confirmedAt DateTime? @db.Timestamptz(3)
  revokedAt   DateTime? @db.Timestamptz(3)

  businessAccount BusinessAccount @relation(fields: [businessAccountId], references: [businessAccountId], onDelete: Cascade)
  userProfile     UserProfile     @relation(fields: [profileId], references: [profileId], onDelete: Cascade)
  approvalVotes   ApprovalVote[]

  @@unique([tenantId, businessAccountId, profileId])
  @@index([tenantId, profileId])
  @@index([tenantId, businessAccountId])
}

model SignatoryRule {
  ruleId            String @id @default(uuid())
  tenantId          String
  businessAccountId String

  // Rule definition
  minAmount         Decimal? @db.Decimal(36, 9) // null = applies to all
  maxAmount         Decimal? @db.Decimal(36, 9) // null = no upper limit
  requiredApprovals Int // e.g., 2 of 3

  // Optional constraints
  transactionType OffChainTxType?
  dailyLimit      Decimal?        @db.Decimal(36, 9)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  businessAccount BusinessAccount @relation(fields: [businessAccountId], references: [businessAccountId], onDelete: Cascade)

  @@index([tenantId, businessAccountId])
  @@index([tenantId, isActive])
}

model TransactionApproval {
  approvalId        String @id @default(uuid())
  tenantId          String
  businessAccountId String
  outboxCommandId   String // Links to OutboxCommand

  // Approval tracking
  requiredApprovals Int
  receivedApprovals Int @default(0)

  status    ApprovalStatus @default(PENDING)
  expiresAt DateTime       @db.Timestamptz(3)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  businessAccount BusinessAccount @relation(fields: [businessAccountId], references: [businessAccountId], onDelete: Cascade)
  outboxCommand   OutboxCommand   @relation(fields: [outboxCommandId], references: [id], onDelete: Cascade)
  approvers       ApprovalVote[]

  @@unique([tenantId, outboxCommandId])
  @@index([tenantId, businessAccountId, status])
  @@index([status, expiresAt])
}

model ApprovalVote {
  voteId      String @id @default(uuid())
  tenantId    String
  approvalId  String
  signatoryId String // BusinessSignatory

  approved Boolean
  remarks  String?
  votedAt  DateTime @default(now()) @db.Timestamptz(3)

  approval  TransactionApproval @relation(fields: [approvalId], references: [approvalId], onDelete: Cascade)
  signatory BusinessSignatory   @relation(fields: [signatoryId], references: [signatoryId], onDelete: Cascade)

  @@unique([tenantId, approvalId, signatoryId])
  @@index([tenantId, signatoryId])
}

// =============================================================================
// SECTION 6: ENHANCED KYC & DOCUMENT MANAGEMENT
// =============================================================================

model KYCDocument {
  documentId String @id @default(uuid())
  tenantId   String
  kycId      String

  // Document metadata
  documentType   DocumentType
  documentNumber String?
  issuingCountry String?      @db.Char(2)
  issuedDate     DateTime?    @db.Date
  expiryDate     DateTime?    @db.Date

  // File storage
  storageUrl String // S3/Azure Blob URL
  fileHash   String // SHA-256
  fileSize   Int // Bytes
  mimeType   String

  // Security
  encryptionKey   String? // If end-to-end encrypted
  virusScanStatus String? // "clean", "infected", "pending"
  virusScanDate   DateTime? @db.Timestamptz(3)

  // Versioning
  version            Int     @default(1)
  replacesDocumentId String? // Previous version

  uploadedAt DateTime  @default(now()) @db.Timestamptz(3)
  verifiedAt DateTime? @db.Timestamptz(3)
  verifiedBy String? // Admin profileId

  kycVerification KYCVerification @relation(fields: [kycId], references: [kycId], onDelete: Cascade)
  country         Country?        @relation(fields: [issuingCountry], references: [countryCode])

  @@index([tenantId, kycId])
  @@index([documentType])
  @@index([fileHash])
}

// =============================================================================
// SECTION 7: FRAUD PREVENTION & TRANSACTION LIMITS
// =============================================================================

model TransactionLimit {
  limitId   String  @id @default(uuid())
  tenantId  String
  profileId String? // null = global default
  walletId  String? // null = applies to all wallets

  limitType   LimitType
  limitAmount Decimal   @db.Decimal(36, 9)

  // Velocity limits
  maxCount          Int? // Max N transactions
  timeWindowMinutes Int? // Per time window

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  userProfile UserProfile? @relation(fields: [profileId], references: [profileId], onDelete: Cascade)

  @@index([tenantId, profileId])
  @@index([tenantId, walletId])
  @@index([tenantId, isActive])
}

model TransactionRiskScore {
  riskId   String @id @default(uuid())
  tenantId String
  offTxId  String @unique // Transaction.offTxId

  riskScore   Int // 0-100
  riskFactors Json // { "unusual_time": true, "new_counterparty": true }

  requiresReview Boolean   @default(false)
  reviewedAt     DateTime? @db.Timestamptz(3)
  reviewedBy     String? // Admin profileId
  reviewNotes    String?

  calculatedAt DateTime @default(now()) @db.Timestamptz(3)

  transaction Transaction @relation(fields: [offTxId], references: [offTxId], onDelete: Cascade)

  @@index([tenantId, requiresReview])
  @@index([tenantId, riskScore])
}

// =============================================================================
// SECTION 8: HOARDING TAX (PER WHITEPAPER)
// =============================================================================

model HoardingTaxSnapshot {
  snapshotId String @id @default(uuid())
  tenantId   String
  walletId   String

  // Snapshot data
  snapshotDate DateTime @db.Date
  balance      Decimal  @db.Decimal(36, 9)
  daysHeld     Int // Days since last >100 GX threshold crossing

  // Tax calculation
  taxableAmount Decimal @db.Decimal(36, 9)
  taxRate       Decimal @db.Decimal(5, 4) // 0.0300 = 3%, 0.0600 = 6%
  taxOwed       Decimal @db.Decimal(36, 9)

  // Status
  taxPaid    Boolean   @default(false)
  paidAt     DateTime? @db.Timestamptz(3)
  fabricTxId String?

  createdAt DateTime @default(now()) @db.Timestamptz(3)

  wallet Wallet @relation(fields: [walletId], references: [walletId], onDelete: Cascade)

  @@unique([tenantId, walletId, snapshotDate])
  @@index([tenantId, snapshotDate, taxPaid])
  @@index([tenantId, taxPaid])
}

// =============================================================================
// SECTION 9: SECURITY - SESSION & DEVICE MANAGEMENT
// =============================================================================

model UserSession {
  sessionId String @id @default(uuid())
  tenantId  String
  profileId String

  // Device info
  deviceId   String // UUID or fingerprint
  deviceName String? // "iPhone 14 Pro"
  deviceOs   String? // "iOS 17.1"
  ipAddress  String
  userAgent  String

  // Session lifecycle
  status         SessionStatus @default(ACTIVE)
  createdAt      DateTime      @default(now()) @db.Timestamptz(3)
  lastActivityAt DateTime      @default(now()) @db.Timestamptz(3)
  expiresAt      DateTime      @db.Timestamptz(3)
  revokedAt      DateTime?     @db.Timestamptz(3)
  revokedReason  String?

  // Security
  refreshToken     String @unique
  refreshTokenHash String // Hashed version for lookup

  userProfile UserProfile @relation(fields: [profileId], references: [profileId], onDelete: Cascade)

  @@unique([tenantId, sessionId])
  @@index([tenantId, profileId, status])
  @@index([refreshTokenHash])
  @@index([expiresAt])
  @@index([tenantId, deviceId])
}

model TrustedDevice {
  deviceId  String @id @default(uuid())
  tenantId  String
  profileId String

  deviceName        String
  deviceFingerprint String  @unique
  deviceOs          String?

  firstSeenAt     DateTime  @default(now()) @db.Timestamptz(3)
  lastSeenAt      DateTime  @default(now()) @db.Timestamptz(3)
  isTrusted       Boolean   @default(false)
  trustVerifiedAt DateTime? @db.Timestamptz(3)

  userProfile UserProfile @relation(fields: [profileId], references: [profileId], onDelete: Cascade)

  @@unique([tenantId, profileId, deviceFingerprint])
  @@index([tenantId, profileId])
  @@index([tenantId, isTrusted])
}

// =============================================================================
// SECTION 10: NOTIFICATION SYSTEM
// =============================================================================

model Notification {
  notificationId String @id @default(uuid())
  tenantId       String
  recipientId    String // UserProfile

  // Content
  type    NotificationType
  title   String
  message String

  // Action metadata
  actionUrl          String? // Deep link to app screen
  actionRequired     Boolean @default(false)
  actionResourceType String? // "FamilyRelationship", "TransactionApproval"
  actionResourceId   String?

  // Status
  status     NotificationStatus @default(UNREAD)
  readAt     DateTime?          @db.Timestamptz(3)
  actionedAt DateTime?          @db.Timestamptz(3)

  // Delivery
  sentViaEmail Boolean   @default(false)
  sentViaPush  Boolean   @default(false)
  emailSentAt  DateTime? @db.Timestamptz(3)
  pushSentAt   DateTime? @db.Timestamptz(3)

  createdAt DateTime  @default(now()) @db.Timestamptz(3)
  expiresAt DateTime? @db.Timestamptz(3)

  recipient UserProfile @relation(fields: [recipientId], references: [profileId], onDelete: Cascade)

  @@index([tenantId, recipientId, status])
  @@index([tenantId, recipientId, createdAt])
  @@index([expiresAt])
  @@index([tenantId, type, status])
}

model PushToken {
  tokenId   String @id @default(uuid())
  tenantId  String
  profileId String

  token    String  @unique
  deviceId String?
  platform String // "ios", "android", "web"

  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now()) @db.Timestamptz(3)
  lastUsedAt DateTime @default(now()) @db.Timestamptz(3)

  userProfile UserProfile @relation(fields: [profileId], references: [profileId], onDelete: Cascade)

  @@unique([tenantId, profileId, token])
  @@index([tenantId, profileId])
  @@index([tenantId, isActive])
}

// =============================================================================
// SECTION 11: AUDIT TRAIL & COMPLIANCE
// =============================================================================

model AuditLog {
  auditId  String @id @default(uuid())
  tenantId String

  // Event details
  eventType       AuditEventType
  actorProfileId  String? // Who performed the action (null for system)
  targetProfileId String? // Who was affected
  resourceType    String? // e.g., "Transaction", "KYCVerification"
  resourceId      String? // UUID of the affected resource

  // Context
  ipAddress String?
  userAgent String?
  deviceId  String?
  sessionId String?

  // Data
  previousValue Json? // Before state (for updates)
  newValue      Json? // After state
  metadata      Json? // Additional context

  // Integrity
  eventHash String // SHA-256 of event data for tamper detection
  timestamp DateTime @default(now()) @db.Timestamptz(3)

  @@index([tenantId, eventType, timestamp])
  @@index([tenantId, actorProfileId, timestamp])
  @@index([tenantId, targetProfileId, timestamp])
  @@index([tenantId, resourceType, resourceId])
  @@index([timestamp])
}

// =============================================================================
// SECTION 12: USER ORGANIZATION LINKS
// =============================================================================

model UserOrganizationLink {
  id            String   @id @default(cuid())
  tenantId      String
  userProfileId String
  orgProfileId  String
  role          String
  addedAt       DateTime @default(now()) @db.Timestamptz(3)

  userProfile         UserProfile         @relation(fields: [userProfileId], references: [profileId], onDelete: Cascade)
  organizationProfile OrganizationProfile @relation(fields: [orgProfileId], references: [orgProfileId], onDelete: Cascade)

  @@unique([tenantId, userProfileId, orgProfileId])
  @@index([userProfileId])
  @@index([orgProfileId])
  @@index([tenantId])
}

// =============================================================================
// SECTION 13: LICENSING & ECONOMIC ACTIVITIES
// =============================================================================

model LicensedPartner {
  partnerId               String        @id @default(uuid())
  tenantId                String
  companyName             String
  jurisdictionCountryCode String        @db.Char(2)
  status                  PartnerStatus @default(PENDING)
  createdAt               DateTime      @default(now()) @db.Timestamptz(3)

  country       Country        @relation(fields: [jurisdictionCountryCode], references: [countryCode])
  applications  Application[]
  partnerGrants PartnerGrant[]

  @@unique([tenantId, companyName])
  @@index([tenantId, status])
}

model Application {
  appId     String   @id @default(uuid())
  tenantId  String
  partnerId String
  appName   String
  createdAt DateTime @default(now()) @db.Timestamptz(3)

  partner  LicensedPartner @relation(fields: [partnerId], references: [partnerId], onDelete: Cascade)
  licenses License[]

  @@unique([tenantId, appName])
  @@index([tenantId, partnerId])
}

model License {
  licenseId   String        @id @default(uuid())
  tenantId    String
  appId       String
  licenseType String
  status      LicenseStatus @default(ACTIVE)
  expiryDate  DateTime?     @db.Timestamptz(3)
  createdAt   DateTime      @default(now()) @db.Timestamptz(3)

  application Application  @relation(fields: [appId], references: [appId], onDelete: Cascade)
  credentials Credential[]

  @@index([tenantId, appId])
  @@index([tenantId, status])
}

model Credential {
  credentialId     String           @id @default(uuid())
  tenantId         String
  licenseId        String
  clientId         String
  clientSecretHash String
  status           CredentialStatus @default(ACTIVE)
  createdAt        DateTime         @default(now()) @db.Timestamptz(3)

  license License @relation(fields: [licenseId], references: [licenseId], onDelete: Cascade)

  @@unique([tenantId, clientId])
  @@index([tenantId, licenseId])
}

model PartnerGrant {
  grantId           String    @id @default(uuid())
  tenantId          String
  partnerId         String
  amount            Decimal   @db.Decimal(36, 9)
  purpose           String?
  issuanceTimestamp DateTime? @db.Timestamptz(3)
  onChainTxId       String?

  partner LicensedPartner @relation(fields: [partnerId], references: [partnerId], onDelete: Cascade)

  @@index([tenantId, partnerId])
}

model Collateral {
  collateralId      String           @id @default(uuid())
  onChainLoanId     String           @unique
  documentReference String
  documentHash      String
  documentSize      Int?
  documentMime      String?
  status            CollateralStatus @default(PLEDGED)
  createdAt         DateTime         @default(now()) @db.Timestamptz(3)

  @@index([onChainLoanId])
  @@index([status])
}

// =============================================================================
// SECTION 14: CQRS & EVENT HANDLING
// =============================================================================

model OutboxCommand {
  id          String       @id @default(cuid())
  tenantId    String
  service     String
  commandType CommandType
  requestId   String
  payload     Json
  status      OutboxStatus @default(PENDING)
  attempts    Int          @default(0)
  lockedBy    String?
  lockedAt    DateTime?    @db.Timestamptz(3)
  submittedAt DateTime?    @db.Timestamptz(3)
  fabricTxId  String?
  commitBlock BigInt?
  errorCode   String?
  error       String?
  createdAt   DateTime     @default(now()) @db.Timestamptz(3)
  updatedAt   DateTime     @updatedAt @db.Timestamptz(3)

  // NEW: Transaction Approval Support
  transactionApprovals TransactionApproval[]

  @@unique([tenantId, requestId])
  @@index([status, createdAt])
  @@index([tenantId, status])
  @@index([fabricTxId])
}

model ProjectorState {
  tenantId       String
  projectorName  String
  channel        String
  lastBlock      BigInt
  lastEventIndex Int
  updatedAt      DateTime @updatedAt @db.Timestamptz(3)

  @@id([tenantId, projectorName, channel])
}

model HttpIdempotency {
  tenantId        String
  method          String
  path            String
  bodyHash        String
  responseBody    Json
  responseHeaders Json?
  statusCode      Int
  createdAt       DateTime  @default(now()) @db.Timestamptz(3)
  ttlExpiresAt    DateTime? @db.Timestamptz(3)

  @@id([tenantId, method, path, bodyHash])
  @@index([ttlExpiresAt])
}

model EventLog {
  id           String   @id @default(cuid())
  tenantId     String
  fabricTxId   String
  blockNumber  BigInt
  channel      String
  chaincode    String
  eventName    String
  eventVersion String
  payload      Json
  txTimestamp  DateTime @db.Timestamptz(3)
  ingestedAt   DateTime @default(now()) @db.Timestamptz(3)

  @@index([tenantId, blockNumber])
  @@index([fabricTxId])
  @@index([tenantId, eventName])
}

model EventDLQ {
  id          String   @id @default(cuid())
  tenantId    String
  reason      String
  rawPayload  Json
  fabricTxId  String?
  blockNumber BigInt?
  channel     String?
  chaincode   String?
  createdAt   DateTime @default(now()) @db.Timestamptz(3)

  @@index([tenantId, createdAt])
}

// ========== Phase 3 Models (Microservices) ==========

model Organization {
  orgId        String    @id
  tenantId     String
  orgName      String
  orgType      String
  status       String // PROPOSED, ACTIVE, SUSPENDED
  stakeholders Json // Array of stakeholder IDs
  endorsers    Json? // Array of endorser IDs
  authRules    Json? // Authorization rules
  activatedAt  DateTime? @db.Timestamptz(3)
  createdAt    DateTime  @default(now()) @db.Timestamptz(3)
  updatedAt    DateTime  @updatedAt @db.Timestamptz(3)

  @@index([tenantId])
  @@index([status])
}

model MultiSigTransaction {
  txId               String    @id
  tenantId           String
  orgId              String
  proposerId         String
  operation          String
  params             Json
  status             String // PENDING, EXECUTED, REJECTED
  requiredSignatures Int
  currentSignatures  Int       @default(0)
  approvers          Json? // Array of approver IDs
  executedAt         DateTime? @db.Timestamptz(3)
  createdAt          DateTime  @default(now()) @db.Timestamptz(3)
  updatedAt          DateTime  @updatedAt @db.Timestamptz(3)

  @@index([tenantId, orgId])
  @@index([status])
}

model Loan {
  loanId         String    @id
  tenantId       String
  borrowerId     String
  amount         Float
  collateralHash String?
  appliedAt      DateTime  @default(now()) @db.Timestamptz(3)
  purpose        String
  status         String // PENDING_APPROVAL, ACTIVE, REPAID, DEFAULTED
  approvedBy     String?
  approvedAt     DateTime? @db.Timestamptz(3)
  createdAt      DateTime  @default(now()) @db.Timestamptz(3)
  updatedAt      DateTime  @updatedAt @db.Timestamptz(3)

  @@index([tenantId, borrowerId])
  @@index([status])
  @@index([appliedAt])
}

model Proposal {
  proposalId   String    @id
  tenantId     String
  title        String
  description  String
  proposerId   String
  proposalType String
  status       String // ACTIVE, EXECUTED, REJECTED
  votesFor     Int       @default(0)
  votesAgainst Int       @default(0)
  voters       Json? // Array of voter IDs
  executedAt   DateTime? @db.Timestamptz(3)
  createdAt    DateTime  @default(now()) @db.Timestamptz(3)
  updatedAt    DateTime  @updatedAt @db.Timestamptz(3)

  @@index([tenantId])
  @@index([status])
  @@index([proposerId])
}

model SystemParameter {
  tenantId   String
  paramKey   String
  paramValue String
  updatedAt  DateTime @updatedAt @db.Timestamptz(3)

  @@id([tenantId, paramKey])
  @@index([tenantId])
}

// =============================================================================
// SECTION 15: ADMIN RBAC SYSTEM
// Hierarchical role-based access control for admin panel
// =============================================================================

/// AdminRole: Hierarchical roles with SUPER_OWNER at top
enum AdminRole {
  SUPER_OWNER // Project owner - ultimate authority
  SUPER_ADMIN // Full admin access (future)
  ADMIN       // Standard admin (Manazir)
  MODERATOR   // Read + limited write (future)
  DEVELOPER   // Development access (future)
  AUDITOR     // Read-only audit access (future)
}

/// MfaMethod: Supported MFA methods
enum MfaMethod {
  TOTP        // Time-based OTP (Google Authenticator)
  SMS_OTP     // SMS-based OTP (future)
  EMAIL_OTP   // Email-based OTP (fallback)
  HARDWARE    // Hardware keys like YubiKey (future)
}

/// PermissionCategory: Groups permissions for easier management
enum PermissionCategory {
  SYSTEM        // System-level operations (pause, resume)
  USER          // User management (approve, freeze)
  FINANCIAL     // Financial operations (treasury, transfers)
  DEPLOYMENT    // Code deployment (devnet, testnet, mainnet)
  AUDIT         // Audit log access
  CONFIG        // Configuration management
}

/// RiskLevel: Used for determining MFA/approval requirements
enum RiskLevel {
  LOW           // No additional verification
  MEDIUM        // MFA required
  HIGH          // MFA + logging
  CRITICAL      // MFA + approval workflow
}

/// ApprovalType: Types of actions requiring approval
enum ApprovalType {
  DEPLOYMENT_PROMOTION  // devnet->testnet, testnet->mainnet
  USER_FREEZE           // Freezing user accounts
  TREASURY_OPERATION    // Treasury activations, withdrawals
  SYSTEM_PAUSE          // Pausing the system
  CONFIG_CHANGE         // Changing system parameters
  ADMIN_ROLE_CHANGE     // Promoting/demoting admins
}

/// AdminApprovalStatus: Status of approval requests (renamed to avoid conflict)
enum AdminApprovalStatus {
  PENDING       // Awaiting approval
  APPROVED      // Approved by SUPER_OWNER
  REJECTED      // Rejected with reason
  EXPIRED       // Approval token expired
  CANCELLED     // Cancelled by requester
}

/// AdminUser: Admin accounts with role-based permissions
model AdminUser {
  id                  String          @id @default(uuid())
  email               String          @unique
  username            String          @unique
  displayName         String
  passwordHash        String

  // MFA Configuration
  mfaEnabled          Boolean         @default(false)
  mfaPrimaryMethod    MfaMethod?
  totpSecret          String?         // Encrypted TOTP secret
  mfaBackupCodes      String[]        // Encrypted backup codes

  // Role & Permissions
  role                AdminRole
  customPermissions   String[]        // Additional permission codes

  // Status
  isActive            Boolean         @default(true)
  lastLoginAt         DateTime?       @db.Timestamptz(3)
  lastLoginIp         String?
  loginFailedAttempts Int             @default(0)
  lockedUntil         DateTime?       @db.Timestamptz(3)

  // Security
  passwordChangedAt   DateTime        @default(now()) @db.Timestamptz(3)
  requirePasswordChange Boolean       @default(false)

  // Audit
  createdBy           String?         // AdminUser.id who created this
  createdAt           DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt           DateTime        @updatedAt @db.Timestamptz(3)
  deletedAt           DateTime?       @db.Timestamptz(3)

  // Relations
  sessions            AdminSession[]
  auditLogs           AdminAuditLog[]
  approvalRequests    ApprovalRequest[] @relation("Requester")
  approvalDecisions   ApprovalRequest[] @relation("Approver")

  @@index([email])
  @@index([username])
  @@index([role])
  @@index([isActive])
}

/// Permission: Granular permissions for role-based access
model Permission {
  id              String              @id @default(uuid())
  code            String              @unique    // e.g., "deployment:promote:testnet"
  name            String                         // Human-readable name
  description     String?
  category        PermissionCategory

  // Risk assessment
  riskLevel       RiskLevel           @default(LOW)
  requiresMfa     Boolean             @default(false)
  requiresApproval Boolean            @default(false)

  // Audit
  createdAt       DateTime            @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime            @updatedAt @db.Timestamptz(3)

  // Relations
  rolePermissions RolePermission[]

  @@index([category])
  @@index([riskLevel])
}

/// RolePermission: Maps permissions to roles (allows inheritance)
model RolePermission {
  id              String              @id @default(uuid())
  role            AdminRole
  permissionId    String

  // Override defaults
  canDelegate     Boolean             @default(false) // Can grant to others

  createdAt       DateTime            @default(now()) @db.Timestamptz(3)

  permission      Permission          @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([role, permissionId])
  @@index([role])
}

/// ApprovalRequest: Workflow for critical operations requiring SUPER_OWNER approval
model ApprovalRequest {
  id                String              @id @default(uuid())
  requestType       ApprovalType
  requesterId       String              // AdminUser.id

  // Request details
  action            String              // e.g., "promote:testnet:mainnet"
  targetResource    String?             // Resource being affected
  payload           Json?               // Additional context
  reason            String              // Why this action is needed

  // Approval token (cryptographically secure, time-limited)
  approvalToken     String?             @unique
  tokenExpiresAt    DateTime?           @db.Timestamptz(3)

  // Status tracking
  status            AdminApprovalStatus @default(PENDING)
  approverId        String?             // AdminUser.id of approver
  approvedAt        DateTime?           @db.Timestamptz(3)
  rejectedAt        DateTime?           @db.Timestamptz(3)
  rejectionReason   String?

  // Execution tracking
  executedAt        DateTime?           @db.Timestamptz(3)
  executionResult   Json?               // Result of the executed action

  // Audit
  createdAt         DateTime            @default(now()) @db.Timestamptz(3)
  updatedAt         DateTime            @updatedAt @db.Timestamptz(3)

  // Relations
  requester         AdminUser           @relation("Requester", fields: [requesterId], references: [id])
  approver          AdminUser?          @relation("Approver", fields: [approverId], references: [id])

  @@index([requesterId])
  @@index([approverId])
  @@index([status])
  @@index([requestType, status])
  @@index([tokenExpiresAt])
}

/// AdminSession: Tracks admin login sessions with idle timeout
model AdminSession {
  id                String              @id @default(uuid())
  adminId           String

  // Token management
  tokenHash         String              @unique  // SHA256 of JWT
  refreshTokenHash  String?             @unique

  // Session info
  ipAddress         String
  userAgent         String
  deviceFingerprint String?

  // Activity tracking (for idle timeout)
  lastActivityAt    DateTime            @default(now()) @db.Timestamptz(3)
  idleTimeoutMins   Int                 // 30 for ADMIN, 60 for SUPER_OWNER

  // Session lifecycle
  createdAt         DateTime            @default(now()) @db.Timestamptz(3)
  expiresAt         DateTime            @db.Timestamptz(3)
  revokedAt         DateTime?           @db.Timestamptz(3)
  revokeReason      String?

  // MFA state for session
  mfaVerifiedAt     DateTime?           @db.Timestamptz(3)

  admin             AdminUser           @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId])
  @@index([lastActivityAt])
  @@index([expiresAt])
}

/// AdminAuditLog: Immutable audit trail for all admin actions
model AdminAuditLog {
  id                String              @id @default(uuid())
  adminId           String

  // Event details
  action            String              // e.g., "user:approve", "deployment:promote"
  category          PermissionCategory
  resourceType      String?             // e.g., "UserProfile", "Deployment"
  resourceId        String?

  // Context
  ipAddress         String
  userAgent         String
  sessionId         String?

  // Data
  previousValue     Json?               // Before state
  newValue          Json?               // After state
  metadata          Json?               // Additional context

  // Request tracking
  requestId         String?             // For tracing
  approvalRequestId String?             // If action required approval

  // Security - Tamper detection
  eventHash         String              // SHA256(id + action + timestamp + previousHash)
  previousHash      String?             // Chain to previous audit entry

  // Timestamp
  timestamp         DateTime            @default(now()) @db.Timestamptz(3)

  admin             AdminUser           @relation(fields: [adminId], references: [id])

  @@index([adminId])
  @@index([action])
  @@index([category])
  @@index([resourceType, resourceId])
  @@index([timestamp])
  @@index([requestId])
}

/// RbacConfig: Global RBAC configuration settings
model RbacConfig {
  id                        String    @id @default("default")

  // Session timeouts (in minutes)
  adminIdleTimeoutMins      Int       @default(30)
  superOwnerIdleTimeoutMins Int       @default(60)
  maxSessionDurationHours   Int       @default(24)

  // Approval settings
  approvalTokenValidityMins Int       @default(30)    // 30 mins for banking ops
  maxPendingApprovals       Int       @default(10)    // Per requester

  // Password policy
  minPasswordLength         Int       @default(12)
  requireUppercase          Boolean   @default(true)
  requireLowercase          Boolean   @default(true)
  requireNumbers            Boolean   @default(true)
  requireSpecialChars       Boolean   @default(true)
  passwordExpiryDays        Int       @default(90)

  // Lockout policy
  maxLoginAttempts          Int       @default(5)
  lockoutDurationMins       Int       @default(30)

  // MFA settings
  requireMfaForAllAdmins    Boolean   @default(false)
  mfaTotpIssuer             String    @default("GXCoin Admin")

  updatedAt                 DateTime  @updatedAt @db.Timestamptz(3)
  updatedBy                 String?   // AdminUser.id
}

// =============================================================================
// GX COIN PROTOCOL - ENHANCED PRODUCTION SCHEMA
// =============================================================================
// Version: 2.0 (Enhanced)
// Date: October 16, 2025
// 
// This schema incorporates:
// - Multi-tenancy across all tables
// - CQRS/Event-Driven Architecture
// - Trust Score & Family Relationship Tree (80 points)
// - Business Account Governance & Multi-Signature
// - Comprehensive Audit Trail
// - Session & Device Management
// - Notification System
// - Enhanced KYC Document Management
// - Transaction Limits & Fraud Prevention
// - Contact Management
// - Hoarding Tax Calculation
// =============================================================================

generator client {
  provider = "prisma-client-js"
  output   = "../../packages/core-db/node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
// SECTION 1: ENUMs (Custom Data Types)
// =============================================================================

// Existing ENUMs
enum OutboxStatus {
  PENDING
  LOCKED
  SUBMITTED
  COMMITTED
  FAILED
}

enum CommandType {
  // IdentityContract
  CREATE_USER

  // TokenomicsContract
  TRANSFER_TOKENS
  DISTRIBUTE_GENESIS
  FREEZE_WALLET
  UNFREEZE_WALLET

  // OrganizationContract
  PROPOSE_ORGANIZATION
  ENDORSE_MEMBERSHIP
  ACTIVATE_ORGANIZATION
  DEFINE_AUTH_RULE
  INITIATE_MULTISIG_TX
  APPROVE_MULTISIG_TX
  EXECUTE_MULTISIG_TX

  // LoanPoolContract
  APPLY_FOR_LOAN
  APPROVE_LOAN

  // GovernanceContract
  SUBMIT_PROPOSAL
  CAST_VOTE
  EXECUTE_PROPOSAL

  // AdminContract
  BOOTSTRAP_SYSTEM
  INITIALIZE_COUNTRY_DATA
  UPDATE_SYSTEM_PARAMETER
  PAUSE_SYSTEM
  RESUME_SYSTEM
  APPOINT_ADMIN
  ACTIVATE_TREASURY
  MINT                       // Legacy: Token minting (deprecated)

  // TaxAndFeeContract
  APPLY_VELOCITY_TAX

  // Q Send Commands
  Q_SEND_PAY           // Pay a Q Send payment request
}

enum UserProfileStatus {
  REGISTERED
  PENDING_ADMIN_APPROVAL
  APPROVED_PENDING_ONCHAIN
  DENIED
  ACTIVE
  FROZEN
  SUSPENDED
  CLOSED
}

enum KycStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

enum OrgProfileStatus {
  PENDING_VERIFICATION
  VERIFIED
  REJECTED
  SUSPENDED
}

enum PartnerStatus {
  PENDING
  ACTIVE
  REVOKED
}

enum LicenseStatus {
  ACTIVE
  EXPIRED
  REVOKED
}

enum CredentialStatus {
  ACTIVE
  REVOKED
}

enum LegalTenderStatusEnum {
  RECOGNIZED
  SANDBOX
  ACTIVE_LEGAL_TENDER
}

enum OffChainTxType {
  // Core token operations
  MINT                      // System minting new tokens
  GENESIS                   // Initial token allocation

  // P2P transfers
  SENT                      // Outgoing transfer
  RECEIVED                  // Incoming transfer

  // Fees & taxes
  FEE                       // Transaction fees
  TAX                       // Tax deductions (velocity tax, hoarding tax)
  TAX_REFUND                // Tax refund/correction

  // Loans
  LOAN_DISBURSEMENT         // Loan funds received
  LOAN_REPAYMENT            // Loan payment made

  // Donations & grants
  DONATION                  // Charitable donation
  GRANT                     // Grant received

  // Organization/multi-sig
  ORG_DEPOSIT               // Deposit to organization
  ORG_WITHDRAWAL            // Withdrawal from organization
  ORG_DIVIDEND              // Dividend/distribution from org

  // Escrow & holds
  ESCROW_LOCK               // Funds locked in escrow
  ESCROW_RELEASE            // Funds released from escrow
  HOLD                      // Temporary hold on funds
  HOLD_RELEASE              // Hold released

  // Rewards & incentives
  REWARD                    // System reward/incentive
  REFERRAL_BONUS            // Referral program bonus
  STAKING_REWARD            // Staking rewards

  // Corrections & adjustments
  ADJUSTMENT                // Manual adjustment by admin
  REVERSAL                  // Transaction reversal
  REFUND                    // Refund issued
}

enum CollateralStatus {
  PLEDGED
  RELEASED
}

// Registration Step Tracking (Progressive Registration Flow)
enum RegistrationStep {
  EMAIL_PENDING // Initial state
  EMAIL_SENT // OTP sent to email
  EMAIL_VERIFIED // Email OTP verified
  NAME_COUNTRY_SET // First name, last name, country collected
  DOB_GENDER_SET // Date of birth and gender collected
  PASSWORD_SET // Password created
  PHONE_SENT // OTP sent to phone
  PHONE_VERIFIED // Phone OTP verified - registration complete
  COMPLETED // Migrated to UserProfile
}

// Employment Status for KYR Work/Company Details
enum EmploymentStatus {
  EMPLOYED
  SELF_EMPLOYED
  FREELANCER
  STUDENT
  RETIRED
  UNEMPLOYED
  OTHER
}

// Gender enum for user registration
enum Gender {
  MALE
  FEMALE
}

// Address Type for KYR address history
enum AddressType {
  CURRENT // Current residential address
  PREVIOUS // Previous address (kept for history)
  MAILING // Mailing address if different
  WORK // Work address
}

// NEW ENUMs for Enhanced Features
enum RelationType {
  FATHER
  MOTHER
  SPOUSE
  CHILD
  SIBLING
  BUSINESS_PARTNER
  DIRECTOR
  WORKPLACE_ASSOCIATE
  FRIEND
}

enum RelationshipStatus {
  PENDING // Invitation sent, awaiting confirmation
  CONFIRMED // Both parties confirmed
  REJECTED // Rejected by invitee
  DECEASED // Marked deceased with documentation
  DIVORCED // Marked divorced with documentation
  NOT_APPLICABLE // User indicated N/A (triggers re-weighting)
}

enum SignatoryRole {
  OWNER
  DIRECTOR
  AUTHORIZED_SIGNATORY
  ACCOUNTANT
  VIEWER
  INITIATOR           // Can initiate but not approve
  APPROVER            // Can approve transactions
}

/// EntityType: Types of organizational entities
enum EntityType {
  BUSINESS            // For-profit business
  GOVERNMENT          // Government agency/department
  NOT_FOR_PROFIT      // Non-profit organization/charity
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

enum AuditEventType {
  USER_LOGIN
  USER_LOGOUT
  USER_REGISTERED
  PROFILE_UPDATED
  PASSWORD_CHANGED
  KYC_SUBMITTED
  KYC_APPROVED
  KYC_REJECTED
  TRANSACTION_INITIATED
  TRANSACTION_APPROVED
  TRANSACTION_REJECTED
  TRANSACTION_COMPLETED
  TRANSACTION_FAILED
  WALLET_CREATED
  BENEFICIARY_ADDED
  BENEFICIARY_REMOVED
  RELATIONSHIP_INVITED
  RELATIONSHIP_CONFIRMED
  RELATIONSHIP_REJECTED
  BUSINESS_SIGNATORY_ADDED
  BUSINESS_SIGNATORY_REVOKED
  ADMIN_ACCOUNT_FROZEN
  ADMIN_ACCOUNT_UNFROZEN
  ADMIN_ACCOUNT_CLOSED
  SESSION_CREATED
  SESSION_REVOKED
  DEVICE_TRUSTED
  DEVICE_UNTRUSTED
}

enum SessionStatus {
  ACTIVE
  EXPIRED
  REVOKED
  LOGGED_OUT
}

enum NotificationType {
  RELATIONSHIP_INVITATION
  RELATIONSHIP_CONFIRMED
  RELATIONSHIP_REJECTED
  BUSINESS_SIGNATORY_INVITATION
  TRANSACTION_APPROVAL_REQUEST
  TRANSACTION_APPROVED
  TRANSACTION_REJECTED
  TRANSACTION_COMPLETED
  KYC_STATUS_UPDATE
  WALLET_CREDITED
  WALLET_DEBITED
  SYSTEM_ANNOUNCEMENT
  SECURITY_ALERT
  // Admin approval workflow notifications
  ADMIN_APPROVAL_REQUESTED
  ADMIN_APPROVAL_APPROVED
  ADMIN_APPROVAL_REJECTED
  ADMIN_APPROVAL_CANCELLED
  ADMIN_APPROVAL_EXPIRED
  ADMIN_APPROVAL_EXECUTED

  // Q Send notifications
  QSEND_REQUEST_CREATED     // Notification when someone creates a request for you
  QSEND_PAYMENT_RECEIVED    // Creator notified when payment is received
  QSEND_PAYMENT_SENT        // Payer notified when payment is completed
  QSEND_REQUEST_EXPIRED     // Creator notified when request expires unpaid
}

enum NotificationStatus {
  UNREAD
  READ
  ARCHIVED
  ACTIONED
}

enum DocumentType {
  NATIONAL_ID
  PASSPORT
  DRIVERS_LICENSE
  PROOF_OF_ADDRESS
  DEATH_CERTIFICATE
  DIVORCE_CERTIFICATE
  BUSINESS_REGISTRATION
  TAX_REGISTRATION
  BANK_STATEMENT
  UTILITY_BILL
  SELFIE_PHOTO
  OTHER
}

enum LimitType {
  DAILY_SEND
  DAILY_RECEIVE
  MONTHLY_SEND
  MONTHLY_RECEIVE
  SINGLE_TRANSACTION
  VELOCITY_CHECK
}

enum ContactStatus {
  ACTIVE
  BLOCKED
  ARCHIVED
}

// =============================================================================
// SECTION 2: PROGRESSIVE REGISTRATION (Pre-UserProfile)
// =============================================================================

/// PendingRegistration: Stores progressive registration data before migration to UserProfile.
/// This implements a Wise.com-style registration flow where each step saves to the database.
/// Upon completing phone verification, the data is migrated to UserProfile and this record is
/// marked as COMPLETED (or optionally deleted after a retention period).
///
/// Test OTP: During development/testing, use "111111" as the OTP code for both email and phone.
/// This allows testing the full registration flow without a real SMS/email provider.
model PendingRegistration {
  id       String @id @default(uuid())
  tenantId String @default("default")

  // Step 1 & 2: Email verification
  email             String    @unique
  emailOtpHash      String? // bcrypt hash of OTP
  emailOtpExpiresAt DateTime? @db.Timestamptz(3)
  emailOtpAttempts  Int       @default(0) // Rate limiting: max 5 attempts
  emailVerified     Boolean   @default(false)
  emailVerifiedAt   DateTime? @db.Timestamptz(3)

  // Step 3: Name & Country
  firstName   String?
  lastName    String?
  countryCode String? @db.Char(2) // ISO 3166-1 alpha-2

  // Step 4: DOB & Gender (required for Fabric User ID generation and genesis eligibility)
  dateOfBirth DateTime? @db.Date
  gender      Gender?

  // Step 5: Password
  passwordHash String?

  // Step 6 & 7: Phone verification
  phoneNum          String?   @unique
  phoneOtpHash      String? // bcrypt hash of OTP
  phoneOtpExpiresAt DateTime? @db.Timestamptz(3)
  phoneOtpAttempts  Int       @default(0) // Rate limiting: max 5 attempts
  phoneVerified     Boolean   @default(false)
  phoneVerifiedAt   DateTime? @db.Timestamptz(3)

  // Progress tracking
  currentStep RegistrationStep @default(EMAIL_PENDING)

  // Security & Audit
  ipAddress String? // For fraud detection
  userAgent String? // Browser/device info

  // Timestamps & Expiry
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)
  expiresAt DateTime @db.Timestamptz(3) // Auto-cleanup incomplete registrations (24h)

  // Migration tracking (after successful registration)
  migratedToProfileId String?   @unique // UserProfile.profileId after completion
  migratedAt          DateTime? @db.Timestamptz(3)

  @@index([tenantId, currentStep])
  @@index([tenantId, email])
  @@index([tenantId, phoneNum])
  @@index([expiresAt]) // For cleanup job
  @@index([createdAt])
}

// =============================================================================
// SECTION 3: CORE IDENTITY & GOVERNANCE MODELS
// =============================================================================

model Country {
  countryCode          String                @id @db.Char(2)
  countryName          String
  region               String?
  legalTenderStatuses  LegalTenderStatus[]
  organizationProfiles OrganizationProfile[]
  licensedPartners     LicensedPartner[]
  kycDocuments         KYCDocument[]
  userProfiles         UserProfile[] // Users with this nationality
}

model LegalTenderStatus {
  statusId      String                @id @default(uuid())
  countryCode   String                @db.Char(2)
  status        LegalTenderStatusEnum
  effectiveDate DateTime              @db.Timestamptz(3)
  createdAt     DateTime              @default(now()) @db.Timestamptz(3)
  country       Country               @relation(fields: [countryCode], references: [countryCode])

  @@index([countryCode, effectiveDate])
}

model UserProfile {
  profileId String @id @default(uuid())
  tenantId  String

  // Basic identity (from registration)
  firstName              String
  middleName             String? // NEW: Middle name for KYR
  lastName               String
  email                  String?           @unique // Case-insensitive unique index added via migration
  phoneNum               String?           @unique
  biometricHash          String            @unique
  passwordHash           String
  dateOfBirth            DateTime?         @db.Date
  gender                 String? // "male" or "female" - required for Fabric User ID generation
  placeOfBirth           String? // NEW: City/Country of birth for KYR
  nationalityCountryCode String?           @db.Char(2) // For genesis coin distribution to national treasury
  fabricUserId           String?           @unique // Generated deterministic ID (format: CC CCC AANNNN TCCCC NNNN)
  status                 UserProfileStatus @default(REGISTERED)
  onchainStatus          String? // Mirror of blockchain User.Status

  // National ID (MANDATORY during KYR)
  nationalIdNumber    String? // National ID card number
  nationalIdIssuedAt  DateTime? @db.Date
  nationalIdExpiresAt DateTime? @db.Date

  // Passport (OPTIONAL during KYR)
  passportNumber         String?
  passportIssuingCountry String?   @db.Char(2)
  passportIssuedAt       DateTime? @db.Date
  passportExpiresAt      DateTime? @db.Date

  // Employment / Work Details (for future organization sync)
  employmentStatus EmploymentStatus?
  jobTitle         String?
  companyName      String?
  industry         String? // Dropdown from predefined list
  workEmail        String? // For organization verification
  workPhoneNum     String?

  // Compliance flags
  isPEP      Boolean @default(false) // Politically Exposed Person
  pepDetails String? // If isPEP=true, describe position

  // Account lock/freeze management
  isLocked   Boolean   @default(false)
  lockReason String?
  lockedBy   String? // Admin profileId
  lockedAt   DateTime? @db.Timestamptz(3)
  lockNotes  String?

  // Admin review tracking
  reviewedBy   String? // Admin profileId
  reviewedAt   DateTime? @db.Timestamptz(3)
  denialReason String?

  // Blockchain synchronization
  onchainRegisteredAt DateTime? @db.Timestamptz(3)
  lastSyncedAt        DateTime? @db.Timestamptz(3)

  // Soft delete support
  deletedAt DateTime? @db.Timestamptz(3)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  // Existing relations
  kycVerifications  KYCVerification[]
  wallets           Wallet[]
  beneficiaries     Beneficiary[]
  organizationLinks UserOrganizationLink[]

  // NEW: Address history
  addresses Address[]

  // NEW: Trust Score & Relationships
  trustScore             TrustScore?
  initiatedRelationships FamilyRelationship[] @relation("InitiatedRelationships")
  receivedRelationships  FamilyRelationship[] @relation("ReceivedRelationships")

  // NEW: Security & Sessions
  sessions       UserSession[]
  trustedDevices TrustedDevice[]

  // NEW: Notifications
  notifications Notification[]
  pushTokens    PushToken[]

  // NEW: Business Governance
  businessSignatories BusinessSignatory[]

  // NEW: Contact Management
  ownedContacts Contact[] @relation("OwnedContacts")
  contactedBy   Contact[] @relation("ContactedBy")

  // NEW: Transaction Limits
  transactionLimits TransactionLimit[]

  // Q Send: QR-based payment requests
  qsendCreated  QSendRequest[] @relation("QSendCreator")  // Payment requests I created
  qsendPaid     QSendRequest[] @relation("QSendPayer")    // Payment requests I paid

  // Phase 1: Enhanced wallet features
  accountContexts     AccountContext[]
  transactionCategories TransactionCategory[]
  contactGroups       ContactGroup[]
  coinRequestsSent    CoinRequest[] @relation("CoinRequester")
  coinRequestsReceived CoinRequest[] @relation("CoinRequestee")
  dailyAnalytics      DailyAnalytics[]
  monthlyAnalytics    MonthlyAnalytics[]

  // Phase 3: Business & Enterprise Features
  employeeRecords     Employee[]

  // Phase 4: Government & NPO Account Signatory Relations
  governmentSignatories GovernmentSignatory[]
  npoSignatories        NPOSignatory[]
  npoDonations          NPODonation[]         // Donations made by this user

  // Relations to Country
  nationalityCountry Country? @relation(fields: [nationalityCountryCode], references: [countryCode])

  @@index([tenantId, status])
  @@index([tenantId, email])
  @@index([tenantId, phoneNum])
  @@index([tenantId, deletedAt])
  @@index([tenantId, nationalityCountryCode])
  @@index([fabricUserId])
  @@index([isLocked])
  @@index([reviewedBy])
  // Unique constraint: National ID must be unique within a country
  @@unique([nationalityCountryCode, nationalIdNumber], name: "unique_national_id_per_country")
}

/// Address: Stores user address history for KYR verification.
/// Maintains history of addresses with proof documents for compliance.
model Address {
  addressId String @id @default(uuid())
  tenantId  String
  profileId String

  // Address type
  addressType AddressType @default(CURRENT)
  isCurrent   Boolean     @default(true) // Only one CURRENT per user

  // Address fields
  addressLine1  String
  addressLine2  String?
  city          String
  stateProvince String?
  postalCode    String?
  countryCode   String  @db.Char(2) // ISO 3166-1 alpha-2

  // Proof of address document (for KYR)
  proofDocumentUrl  String? // S3/storage URL
  proofDocumentHash String? // SHA-256 for integrity
  proofDocumentType String? // "utility_bill", "bank_statement", etc.
  proofUploadedAt   DateTime? @db.Timestamptz(3)

  // Verification
  isVerified Boolean   @default(false)
  verifiedAt DateTime? @db.Timestamptz(3)
  verifiedBy String? // Admin profileId

  // History tracking
  validFrom DateTime  @default(now()) @db.Timestamptz(3)
  validTo   DateTime? @db.Timestamptz(3) // null = current address

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  userProfile UserProfile @relation(fields: [profileId], references: [profileId], onDelete: Cascade)

  @@index([tenantId, profileId])
  @@index([tenantId, profileId, addressType])
  @@index([tenantId, profileId, isCurrent])
  @@index([countryCode])
}

model KYCVerification {
  kycId           String    @id @default(uuid())
  profileId       String
  status          KycStatus
  verifiedAt      DateTime? @db.Timestamptz(3)
  verifierDetails String?

  // Legacy fields (kept for backward compatibility)
  evidenceHash String? // sha256 of doc bundle
  evidenceSize Int? // bytes
  evidenceMime String?

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  userProfile UserProfile @relation(fields: [profileId], references: [profileId], onDelete: Cascade)

  // NEW: Document management
  documents KYCDocument[]

  @@index([profileId])
  @@index([status])
}

model OrganizationProfile {
  orgProfileId            String           @id @default(uuid())
  tenantId                String
  legalName               String
  registrationNumber      String?
  jurisdictionCountryCode String           @db.Char(2)
  address                 String?
  status                  OrgProfileStatus @default(PENDING_VERIFICATION)

  // Phase 4: Entity type classification
  entityType              EntityType       @default(BUSINESS)

  // Soft delete support
  deletedAt DateTime? @db.Timestamptz(3)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  country   Country                @relation(fields: [jurisdictionCountryCode], references: [countryCode])
  userLinks UserOrganizationLink[]

  // Entity Account Support (Business, Government, Not-for-Profit)
  businessAccounts     BusinessAccount[]
  governmentAccounts   GovernmentAccount[]
  notForProfitAccounts NotForProfitAccount[]

  @@index([tenantId, status])
  @@index([tenantId, deletedAt])
  @@index([tenantId, entityType])
}

// =============================================================================
// SECTION 3: TRUST SCORE & FAMILY RELATIONSHIPS
// =============================================================================

model FamilyRelationship {
  relationshipId     String             @id @default(uuid())
  tenantId           String
  initiatorProfileId String // User who sent the invite
  relatedProfileId   String? // Target user (null if not on platform yet)
  relatedEmail       String? // For off-platform invitations
  relationType       RelationType
  status             RelationshipStatus @default(PENDING)

  // Status documentation
  statusDocumentUrl  String? // Death cert, divorce cert, etc.
  statusDocumentHash String?
  statusRemarks      String?

  // Confirmation workflow
  confirmedAt DateTime? @db.Timestamptz(3)
  rejectedAt  DateTime? @db.Timestamptz(3)

  // Trust score contribution
  pointsAwarded Int     @default(0)
  isApplicable  Boolean @default(true)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  initiator UserProfile  @relation("InitiatedRelationships", fields: [initiatorProfileId], references: [profileId], onDelete: Cascade)
  related   UserProfile? @relation("ReceivedRelationships", fields: [relatedProfileId], references: [profileId], onDelete: Cascade)

  @@unique([tenantId, initiatorProfileId, relatedProfileId, relationType])
  @@index([tenantId, initiatorProfileId])
  @@index([tenantId, relatedProfileId])
  @@index([tenantId, status])
  @@index([tenantId, relationType, status])
}

model TrustScore {
  profileId String @id
  tenantId  String

  // Score breakdown (max 100 points)
  familyScore   Int @default(0) // Max 80
  businessScore Int @default(0) // Max 10
  friendsScore  Int @default(0) // Max 10
  totalScore    Int @default(0) // Max 100

  // Weighting factors (for dynamic re-weighting when categories N/A)
  familyWeight   Decimal @default(0.80) @db.Decimal(5, 2)
  businessWeight Decimal @default(0.10) @db.Decimal(5, 2)
  friendsWeight  Decimal @default(0.10) @db.Decimal(5, 2)

  // Meta
  lastCalculatedAt   DateTime @db.Timestamptz(3)
  calculationVersion String   @default("1.0")

  userProfile UserProfile @relation(fields: [profileId], references: [profileId], onDelete: Cascade)

  @@index([tenantId, totalScore])
}

// =============================================================================
// SECTION 4: WALLET & TRANSACTIONS
// =============================================================================

model Wallet {
  walletId         String  @id @default(uuid())
  tenantId         String
  profileId        String
  primaryAccountId String
  walletName       String
  cachedBalance    Decimal @default(0) @db.Decimal(36, 9)

  // Soft delete support
  deletedAt DateTime? @db.Timestamptz(3)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  userProfile  UserProfile   @relation(fields: [profileId], references: [profileId], onDelete: Cascade)
  transactions Transaction[]

  // NEW: Business Account Support
  businessAccount BusinessAccount?

  // Phase 4: Government & NPO Account Support
  governmentAccount   GovernmentAccount?
  notForProfitAccount NotForProfitAccount?

  // NEW: Hoarding Tax
  hoardingTaxSnapshots HoardingTaxSnapshot[]

  // Phase 1: Enhanced wallet features
  subAccounts       SubAccount[]
  allocationRules   AllocationRule[]
  budgetPeriods     BudgetPeriod[]
  dailyAnalytics    DailyAnalytics[]
  monthlyAnalytics  MonthlyAnalytics[]

  @@unique([tenantId, primaryAccountId])
  @@index([tenantId, profileId])
  @@index([tenantId, deletedAt])
}

model Transaction {
  offTxId      String         @id @default(uuid())
  tenantId     String
  onChainTxId  String?
  walletId     String
  type         OffChainTxType
  counterparty String
  amount       Decimal        @db.Decimal(36, 9)
  fee          Decimal        @default(0) @db.Decimal(36, 9)
  remark       String?
  timestamp    DateTime       @db.Timestamptz(3)
  blockNumber  BigInt?

  wallet Wallet @relation(fields: [walletId], references: [walletId], onDelete: Cascade)

  // NEW: Risk Scoring
  riskScore TransactionRiskScore?

  // Phase 1: Enhanced transaction features
  tags              TransactionTag[]
  receipt           TransactionReceipt?
  subAccountTransactions SubAccountTransaction[]

  @@unique([tenantId, onChainTxId])
  @@index([tenantId, walletId, timestamp])
  @@index([tenantId, counterparty, timestamp])
  @@index([timestamp])
}

model Beneficiary {
  beneficiaryId         String @id @default(uuid())
  tenantId              String
  ownerProfileId        String
  beneficiaryIdentityId String
  nickname              String

  createdAt DateTime @default(now()) @db.Timestamptz(3)

  userProfile UserProfile @relation(fields: [ownerProfileId], references: [profileId], onDelete: Cascade)

  @@unique([tenantId, ownerProfileId, beneficiaryIdentityId])
  @@index([ownerProfileId])
}

model Contact {
  contactId      String @id @default(uuid())
  tenantId       String
  ownerProfileId String

  // Contact details
  contactProfileId String? // If registered on GX
  displayName      String
  phoneNumber      String?
  email            String?
  notes            String?

  // Metadata
  isFavorite        Boolean   @default(false)
  transactionCount  Int       @default(0)
  lastTransactionAt DateTime? @db.Timestamptz(3)

  status    ContactStatus @default(ACTIVE)
  createdAt DateTime      @default(now()) @db.Timestamptz(3)
  updatedAt DateTime      @updatedAt @db.Timestamptz(3)

  owner          UserProfile  @relation("OwnedContacts", fields: [ownerProfileId], references: [profileId], onDelete: Cascade)
  contactProfile UserProfile? @relation("ContactedBy", fields: [contactProfileId], references: [profileId], onDelete: SetNull)

  // Phase 1: Contact groups
  groupMemberships ContactGroupMember[]

  @@unique([tenantId, ownerProfileId, contactProfileId])
  @@index([tenantId, ownerProfileId])
  @@index([tenantId, status])
}

// =============================================================================
// SECTION 5: BUSINESS ACCOUNTS & MULTI-SIGNATURE
// =============================================================================

model BusinessAccount {
  businessAccountId String @id @default(uuid())
  tenantId          String
  orgProfileId      String // Links to OrganizationProfile
  walletId          String @unique

  // Multi-sig configuration
  defaultRequiredApprovals Int @default(1)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  organization     OrganizationProfile   @relation(fields: [orgProfileId], references: [orgProfileId], onDelete: Cascade)
  wallet           Wallet                @relation(fields: [walletId], references: [walletId])
  signatories      BusinessSignatory[]
  signatoryRules   SignatoryRule[]
  pendingApprovals TransactionApproval[]

  // Phase 1: Context switching
  accountContexts  AccountContext[]

  // Phase 3: Business & Enterprise Features
  businessSubAccounts BusinessSubAccount[]
  employees           Employee[]
  payrollBatches      PayrollBatch[]
  businessReports     BusinessReport[]

  @@unique([tenantId, orgProfileId])
  @@index([tenantId])
}

model BusinessSignatory {
  signatoryId       String        @id @default(uuid())
  tenantId          String
  businessAccountId String
  profileId         String // UserProfile
  role              SignatoryRole

  // Permissions
  canInitiateTransactions Boolean  @default(false)
  canApproveTransactions  Boolean  @default(false)
  maxTransactionLimit     Decimal? @db.Decimal(36, 9)

  // Status
  invitedAt   DateTime  @default(now()) @db.Timestamptz(3)
  confirmedAt DateTime? @db.Timestamptz(3)
  revokedAt   DateTime? @db.Timestamptz(3)

  businessAccount BusinessAccount @relation(fields: [businessAccountId], references: [businessAccountId], onDelete: Cascade)
  userProfile     UserProfile     @relation(fields: [profileId], references: [profileId], onDelete: Cascade)
  approvalVotes   ApprovalVote[]

  @@unique([tenantId, businessAccountId, profileId])
  @@index([tenantId, profileId])
  @@index([tenantId, businessAccountId])
}

model SignatoryRule {
  ruleId            String @id @default(uuid())
  tenantId          String
  businessAccountId String

  // Rule definition
  minAmount         Decimal? @db.Decimal(36, 9) // null = applies to all
  maxAmount         Decimal? @db.Decimal(36, 9) // null = no upper limit
  requiredApprovals Int // e.g., 2 of 3

  // Optional constraints
  transactionType OffChainTxType?
  dailyLimit      Decimal?        @db.Decimal(36, 9)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  businessAccount BusinessAccount @relation(fields: [businessAccountId], references: [businessAccountId], onDelete: Cascade)

  @@index([tenantId, businessAccountId])
  @@index([tenantId, isActive])
}

model TransactionApproval {
  approvalId        String @id @default(uuid())
  tenantId          String
  businessAccountId String
  outboxCommandId   String // Links to OutboxCommand

  // Approval tracking
  requiredApprovals Int
  receivedApprovals Int @default(0)

  status    ApprovalStatus @default(PENDING)
  expiresAt DateTime       @db.Timestamptz(3)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  businessAccount BusinessAccount @relation(fields: [businessAccountId], references: [businessAccountId], onDelete: Cascade)
  outboxCommand   OutboxCommand   @relation(fields: [outboxCommandId], references: [id], onDelete: Cascade)
  approvers       ApprovalVote[]

  @@unique([tenantId, outboxCommandId])
  @@index([tenantId, businessAccountId, status])
  @@index([status, expiresAt])
}

model ApprovalVote {
  voteId      String @id @default(uuid())
  tenantId    String
  approvalId  String
  signatoryId String // BusinessSignatory

  approved Boolean
  remarks  String?
  votedAt  DateTime @default(now()) @db.Timestamptz(3)

  approval  TransactionApproval @relation(fields: [approvalId], references: [approvalId], onDelete: Cascade)
  signatory BusinessSignatory   @relation(fields: [signatoryId], references: [signatoryId], onDelete: Cascade)

  @@unique([tenantId, approvalId, signatoryId])
  @@index([tenantId, signatoryId])
}

// =============================================================================
// SECTION 6: ENHANCED KYC & DOCUMENT MANAGEMENT
// =============================================================================

model KYCDocument {
  documentId String @id @default(uuid())
  tenantId   String
  kycId      String

  // Document metadata
  documentType   DocumentType
  documentNumber String?
  issuingCountry String?      @db.Char(2)
  issuedDate     DateTime?    @db.Date
  expiryDate     DateTime?    @db.Date

  // File storage
  storageUrl String // S3/Azure Blob URL
  fileHash   String // SHA-256
  fileSize   Int // Bytes
  mimeType   String

  // Security
  encryptionKey   String? // If end-to-end encrypted
  virusScanStatus String? // "clean", "infected", "pending"
  virusScanDate   DateTime? @db.Timestamptz(3)

  // Versioning
  version            Int     @default(1)
  replacesDocumentId String? // Previous version

  uploadedAt DateTime  @default(now()) @db.Timestamptz(3)
  verifiedAt DateTime? @db.Timestamptz(3)
  verifiedBy String? // Admin profileId

  kycVerification KYCVerification @relation(fields: [kycId], references: [kycId], onDelete: Cascade)
  country         Country?        @relation(fields: [issuingCountry], references: [countryCode])

  @@index([tenantId, kycId])
  @@index([documentType])
  @@index([fileHash])
}

// =============================================================================
// SECTION 7: FRAUD PREVENTION & TRANSACTION LIMITS
// =============================================================================

model TransactionLimit {
  limitId   String  @id @default(uuid())
  tenantId  String
  profileId String? // null = global default
  walletId  String? // null = applies to all wallets

  limitType   LimitType
  limitAmount Decimal   @db.Decimal(36, 9)

  // Velocity limits
  maxCount          Int? // Max N transactions
  timeWindowMinutes Int? // Per time window

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  userProfile UserProfile? @relation(fields: [profileId], references: [profileId], onDelete: Cascade)

  @@index([tenantId, profileId])
  @@index([tenantId, walletId])
  @@index([tenantId, isActive])
}

model TransactionRiskScore {
  riskId   String @id @default(uuid())
  tenantId String
  offTxId  String @unique // Transaction.offTxId

  riskScore   Int // 0-100
  riskFactors Json // { "unusual_time": true, "new_counterparty": true }

  requiresReview Boolean   @default(false)
  reviewedAt     DateTime? @db.Timestamptz(3)
  reviewedBy     String? // Admin profileId
  reviewNotes    String?

  calculatedAt DateTime @default(now()) @db.Timestamptz(3)

  transaction Transaction @relation(fields: [offTxId], references: [offTxId], onDelete: Cascade)

  @@index([tenantId, requiresReview])
  @@index([tenantId, riskScore])
}

// =============================================================================
// SECTION 8: HOARDING TAX (PER WHITEPAPER)
// =============================================================================

model HoardingTaxSnapshot {
  snapshotId String @id @default(uuid())
  tenantId   String
  walletId   String

  // Snapshot data
  snapshotDate DateTime @db.Date
  balance      Decimal  @db.Decimal(36, 9)
  daysHeld     Int // Days since last >100 GX threshold crossing

  // Tax calculation
  taxableAmount Decimal @db.Decimal(36, 9)
  taxRate       Decimal @db.Decimal(5, 4) // 0.0300 = 3%, 0.0600 = 6%
  taxOwed       Decimal @db.Decimal(36, 9)

  // Status
  taxPaid    Boolean   @default(false)
  paidAt     DateTime? @db.Timestamptz(3)
  fabricTxId String?

  createdAt DateTime @default(now()) @db.Timestamptz(3)

  wallet Wallet @relation(fields: [walletId], references: [walletId], onDelete: Cascade)

  @@unique([tenantId, walletId, snapshotDate])
  @@index([tenantId, snapshotDate, taxPaid])
  @@index([tenantId, taxPaid])
}

// =============================================================================
// SECTION 9: SECURITY - SESSION & DEVICE MANAGEMENT
// =============================================================================

model UserSession {
  sessionId String @id @default(uuid())
  tenantId  String
  profileId String

  // Device info
  deviceId   String // UUID or fingerprint
  deviceName String? // "iPhone 14 Pro"
  deviceOs   String? // "iOS 17.1"
  ipAddress  String
  userAgent  String

  // Session lifecycle
  status         SessionStatus @default(ACTIVE)
  createdAt      DateTime      @default(now()) @db.Timestamptz(3)
  lastActivityAt DateTime      @default(now()) @db.Timestamptz(3)
  expiresAt      DateTime      @db.Timestamptz(3)
  revokedAt      DateTime?     @db.Timestamptz(3)
  revokedReason  String?

  // Security
  refreshToken     String @unique
  refreshTokenHash String // Hashed version for lookup

  userProfile UserProfile @relation(fields: [profileId], references: [profileId], onDelete: Cascade)

  @@unique([tenantId, sessionId])
  @@index([tenantId, profileId, status])
  @@index([refreshTokenHash])
  @@index([expiresAt])
  @@index([tenantId, deviceId])
}

model TrustedDevice {
  deviceId  String @id @default(uuid())
  tenantId  String
  profileId String

  deviceName        String
  deviceFingerprint String  @unique
  deviceOs          String?

  firstSeenAt     DateTime  @default(now()) @db.Timestamptz(3)
  lastSeenAt      DateTime  @default(now()) @db.Timestamptz(3)
  isTrusted       Boolean   @default(false)
  trustVerifiedAt DateTime? @db.Timestamptz(3)

  userProfile UserProfile @relation(fields: [profileId], references: [profileId], onDelete: Cascade)

  @@unique([tenantId, profileId, deviceFingerprint])
  @@index([tenantId, profileId])
  @@index([tenantId, isTrusted])
}

// =============================================================================
// SECTION 10: NOTIFICATION SYSTEM
// =============================================================================

model Notification {
  notificationId String @id @default(uuid())
  tenantId       String
  recipientId    String // UserProfile

  // Content
  type    NotificationType
  title   String
  message String

  // Action metadata
  actionUrl          String? // Deep link to app screen
  actionRequired     Boolean @default(false)
  actionResourceType String? // "FamilyRelationship", "TransactionApproval"
  actionResourceId   String?

  // Status
  status     NotificationStatus @default(UNREAD)
  readAt     DateTime?          @db.Timestamptz(3)
  actionedAt DateTime?          @db.Timestamptz(3)

  // Delivery
  sentViaEmail Boolean   @default(false)
  sentViaPush  Boolean   @default(false)
  emailSentAt  DateTime? @db.Timestamptz(3)
  pushSentAt   DateTime? @db.Timestamptz(3)

  createdAt DateTime  @default(now()) @db.Timestamptz(3)
  expiresAt DateTime? @db.Timestamptz(3)

  recipient UserProfile @relation(fields: [recipientId], references: [profileId], onDelete: Cascade)

  @@index([tenantId, recipientId, status])
  @@index([tenantId, recipientId, createdAt])
  @@index([expiresAt])
  @@index([tenantId, type, status])
}

model PushToken {
  tokenId   String @id @default(uuid())
  tenantId  String
  profileId String

  token    String  @unique
  deviceId String?
  platform String // "ios", "android", "web"

  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now()) @db.Timestamptz(3)
  lastUsedAt DateTime @default(now()) @db.Timestamptz(3)

  userProfile UserProfile @relation(fields: [profileId], references: [profileId], onDelete: Cascade)

  @@unique([tenantId, profileId, token])
  @@index([tenantId, profileId])
  @@index([tenantId, isActive])
}

// =============================================================================
// SECTION 11: AUDIT TRAIL & COMPLIANCE
// =============================================================================

model AuditLog {
  auditId  String @id @default(uuid())
  tenantId String

  // Event details
  eventType       AuditEventType
  actorProfileId  String? // Who performed the action (null for system)
  targetProfileId String? // Who was affected
  resourceType    String? // e.g., "Transaction", "KYCVerification"
  resourceId      String? // UUID of the affected resource

  // Context
  ipAddress String?
  userAgent String?
  deviceId  String?
  sessionId String?

  // Data
  previousValue Json? // Before state (for updates)
  newValue      Json? // After state
  metadata      Json? // Additional context

  // Integrity
  eventHash String // SHA-256 of event data for tamper detection
  timestamp DateTime @default(now()) @db.Timestamptz(3)

  @@index([tenantId, eventType, timestamp])
  @@index([tenantId, actorProfileId, timestamp])
  @@index([tenantId, targetProfileId, timestamp])
  @@index([tenantId, resourceType, resourceId])
  @@index([timestamp])
}

// =============================================================================
// SECTION 12: USER ORGANIZATION LINKS
// =============================================================================

model UserOrganizationLink {
  id            String   @id @default(cuid())
  tenantId      String
  userProfileId String
  orgProfileId  String
  role          String
  addedAt       DateTime @default(now()) @db.Timestamptz(3)

  userProfile         UserProfile         @relation(fields: [userProfileId], references: [profileId], onDelete: Cascade)
  organizationProfile OrganizationProfile @relation(fields: [orgProfileId], references: [orgProfileId], onDelete: Cascade)

  @@unique([tenantId, userProfileId, orgProfileId])
  @@index([userProfileId])
  @@index([orgProfileId])
  @@index([tenantId])
}

// =============================================================================
// SECTION 13: LICENSING & ECONOMIC ACTIVITIES
// =============================================================================

model LicensedPartner {
  partnerId               String        @id @default(uuid())
  tenantId                String
  companyName             String
  jurisdictionCountryCode String        @db.Char(2)
  status                  PartnerStatus @default(PENDING)
  createdAt               DateTime      @default(now()) @db.Timestamptz(3)

  country       Country        @relation(fields: [jurisdictionCountryCode], references: [countryCode])
  applications  Application[]
  partnerGrants PartnerGrant[]

  @@unique([tenantId, companyName])
  @@index([tenantId, status])
}

model Application {
  appId     String   @id @default(uuid())
  tenantId  String
  partnerId String
  appName   String
  createdAt DateTime @default(now()) @db.Timestamptz(3)

  partner  LicensedPartner @relation(fields: [partnerId], references: [partnerId], onDelete: Cascade)
  licenses License[]

  @@unique([tenantId, appName])
  @@index([tenantId, partnerId])
}

model License {
  licenseId   String        @id @default(uuid())
  tenantId    String
  appId       String
  licenseType String
  status      LicenseStatus @default(ACTIVE)
  expiryDate  DateTime?     @db.Timestamptz(3)
  createdAt   DateTime      @default(now()) @db.Timestamptz(3)

  application Application  @relation(fields: [appId], references: [appId], onDelete: Cascade)
  credentials Credential[]

  @@index([tenantId, appId])
  @@index([tenantId, status])
}

model Credential {
  credentialId     String           @id @default(uuid())
  tenantId         String
  licenseId        String
  clientId         String
  clientSecretHash String
  status           CredentialStatus @default(ACTIVE)
  createdAt        DateTime         @default(now()) @db.Timestamptz(3)

  license License @relation(fields: [licenseId], references: [licenseId], onDelete: Cascade)

  @@unique([tenantId, clientId])
  @@index([tenantId, licenseId])
}

model PartnerGrant {
  grantId           String    @id @default(uuid())
  tenantId          String
  partnerId         String
  amount            Decimal   @db.Decimal(36, 9)
  purpose           String?
  issuanceTimestamp DateTime? @db.Timestamptz(3)
  onChainTxId       String?

  partner LicensedPartner @relation(fields: [partnerId], references: [partnerId], onDelete: Cascade)

  @@index([tenantId, partnerId])
}

model Collateral {
  collateralId      String           @id @default(uuid())
  onChainLoanId     String           @unique
  documentReference String
  documentHash      String
  documentSize      Int?
  documentMime      String?
  status            CollateralStatus @default(PLEDGED)
  createdAt         DateTime         @default(now()) @db.Timestamptz(3)

  @@index([onChainLoanId])
  @@index([status])
}

// =============================================================================
// SECTION 14: CQRS & EVENT HANDLING
// =============================================================================

model OutboxCommand {
  id          String       @id @default(cuid())
  tenantId    String
  service     String
  commandType CommandType
  requestId   String
  payload     Json
  status      OutboxStatus @default(PENDING)
  attempts    Int          @default(0)
  lockedBy    String?
  lockedAt    DateTime?    @db.Timestamptz(3)
  submittedAt DateTime?    @db.Timestamptz(3)
  fabricTxId  String?
  commitBlock BigInt?
  errorCode   String?
  error       String?
  createdAt   DateTime     @default(now()) @db.Timestamptz(3)
  updatedAt   DateTime     @updatedAt @db.Timestamptz(3)

  // NEW: Transaction Approval Support
  transactionApprovals TransactionApproval[]

  @@unique([tenantId, requestId])
  @@index([status, createdAt])
  @@index([tenantId, status])
  @@index([fabricTxId])
}

model ProjectorState {
  tenantId       String
  projectorName  String
  channel        String
  lastBlock      BigInt
  lastEventIndex Int
  updatedAt      DateTime @updatedAt @db.Timestamptz(3)

  @@id([tenantId, projectorName, channel])
}

model HttpIdempotency {
  tenantId        String
  method          String
  path            String
  bodyHash        String
  responseBody    Json
  responseHeaders Json?
  statusCode      Int
  createdAt       DateTime  @default(now()) @db.Timestamptz(3)
  ttlExpiresAt    DateTime? @db.Timestamptz(3)

  @@id([tenantId, method, path, bodyHash])
  @@index([ttlExpiresAt])
}

model EventLog {
  id           String   @id @default(cuid())
  tenantId     String
  fabricTxId   String
  blockNumber  BigInt
  channel      String
  chaincode    String
  eventName    String
  eventVersion String
  payload      Json
  txTimestamp  DateTime @db.Timestamptz(3)
  ingestedAt   DateTime @default(now()) @db.Timestamptz(3)

  @@index([tenantId, blockNumber])
  @@index([fabricTxId])
  @@index([tenantId, eventName])
}

model EventDLQ {
  id          String   @id @default(cuid())
  tenantId    String
  reason      String
  rawPayload  Json
  fabricTxId  String?
  blockNumber BigInt?
  channel     String?
  chaincode   String?
  createdAt   DateTime @default(now()) @db.Timestamptz(3)

  @@index([tenantId, createdAt])
}

// ========== Phase 3 Models (Microservices) ==========

model Organization {
  orgId        String    @id
  tenantId     String
  orgName      String
  orgType      String
  status       String // PROPOSED, ACTIVE, SUSPENDED
  stakeholders Json // Array of stakeholder IDs
  endorsers    Json? // Array of endorser IDs
  authRules    Json? // Authorization rules
  activatedAt  DateTime? @db.Timestamptz(3)
  createdAt    DateTime  @default(now()) @db.Timestamptz(3)
  updatedAt    DateTime  @updatedAt @db.Timestamptz(3)

  @@index([tenantId])
  @@index([status])
}

model MultiSigTransaction {
  txId               String    @id
  tenantId           String
  orgId              String
  proposerId         String
  operation          String
  params             Json
  status             String // PENDING, EXECUTED, REJECTED
  requiredSignatures Int
  currentSignatures  Int       @default(0)
  approvers          Json? // Array of approver IDs
  executedAt         DateTime? @db.Timestamptz(3)
  createdAt          DateTime  @default(now()) @db.Timestamptz(3)
  updatedAt          DateTime  @updatedAt @db.Timestamptz(3)

  @@index([tenantId, orgId])
  @@index([status])
}

model Loan {
  loanId         String    @id
  tenantId       String
  borrowerId     String
  amount         Float
  collateralHash String?
  appliedAt      DateTime  @default(now()) @db.Timestamptz(3)
  purpose        String
  status         String // PENDING_APPROVAL, ACTIVE, REPAID, DEFAULTED
  approvedBy     String?
  approvedAt     DateTime? @db.Timestamptz(3)
  createdAt      DateTime  @default(now()) @db.Timestamptz(3)
  updatedAt      DateTime  @updatedAt @db.Timestamptz(3)

  @@index([tenantId, borrowerId])
  @@index([status])
  @@index([appliedAt])
}

model Proposal {
  proposalId   String    @id
  tenantId     String
  title        String
  description  String
  proposerId   String
  proposalType String
  status       String // ACTIVE, EXECUTED, REJECTED
  votesFor     Int       @default(0)
  votesAgainst Int       @default(0)
  voters       Json? // Array of voter IDs
  executedAt   DateTime? @db.Timestamptz(3)
  createdAt    DateTime  @default(now()) @db.Timestamptz(3)
  updatedAt    DateTime  @updatedAt @db.Timestamptz(3)

  @@index([tenantId])
  @@index([status])
  @@index([proposerId])
}

model SystemParameter {
  tenantId   String
  paramKey   String
  paramValue String
  updatedAt  DateTime @updatedAt @db.Timestamptz(3)

  @@id([tenantId, paramKey])
  @@index([tenantId])
}

// =============================================================================
// SECTION 15: ADMIN RBAC SYSTEM
// Hierarchical role-based access control for admin panel
// =============================================================================

/// AdminRole: Hierarchical roles with SUPER_OWNER at top
enum AdminRole {
  SUPER_OWNER // Project owner - ultimate authority
  SUPER_ADMIN // Full admin access (future)
  ADMIN       // Standard admin (Manazir)
  MODERATOR   // Read + limited write (future)
  DEVELOPER   // Development access (future)
  AUDITOR     // Read-only audit access (future)
}

/// MfaMethod: Supported MFA methods
enum MfaMethod {
  TOTP        // Time-based OTP (Google Authenticator)
  SMS_OTP     // SMS-based OTP (future)
  EMAIL_OTP   // Email-based OTP (fallback)
  HARDWARE    // Hardware keys like YubiKey (future)
}

/// PermissionCategory: Groups permissions for easier management
enum PermissionCategory {
  SYSTEM        // System-level operations (pause, resume)
  USER          // User management (approve, freeze)
  FINANCIAL     // Financial operations (treasury, transfers)
  DEPLOYMENT    // Code deployment (devnet, testnet, mainnet)
  AUDIT         // Audit log access
  CONFIG        // Configuration management
}

/// RiskLevel: Used for determining MFA/approval requirements
enum RiskLevel {
  LOW           // No additional verification
  MEDIUM        // MFA required
  HIGH          // MFA + logging
  CRITICAL      // MFA + approval workflow
}

/// ApprovalType: Types of actions requiring approval
enum ApprovalType {
  DEPLOYMENT_PROMOTION  // devnet->testnet, testnet->mainnet
  USER_FREEZE           // Freezing user accounts
  TREASURY_OPERATION    // Treasury activations, withdrawals
  SYSTEM_PAUSE          // Pausing the system
  CONFIG_CHANGE         // Changing system parameters
  ADMIN_ROLE_CHANGE     // Promoting/demoting admins
}

/// AdminApprovalStatus: Status of approval requests (renamed to avoid conflict)
enum AdminApprovalStatus {
  PENDING       // Awaiting approval
  APPROVED      // Approved by SUPER_OWNER
  REJECTED      // Rejected with reason
  EXPIRED       // Approval token expired
  CANCELLED     // Cancelled by requester
}

/// AdminUser: Admin accounts with role-based permissions
model AdminUser {
  id                  String          @id @default(uuid())
  email               String          @unique
  username            String          @unique
  displayName         String
  passwordHash        String

  // MFA Configuration
  mfaEnabled          Boolean         @default(false)
  mfaPrimaryMethod    MfaMethod?
  totpSecret          String?         // Encrypted TOTP secret
  mfaBackupCodes      String[]        // Encrypted backup codes

  // Role & Permissions
  role                AdminRole
  customPermissions   String[]        // Additional permission codes

  // Status
  isActive            Boolean         @default(true)
  lastLoginAt         DateTime?       @db.Timestamptz(3)
  lastLoginIp         String?
  loginFailedAttempts Int             @default(0)
  lockedUntil         DateTime?       @db.Timestamptz(3)

  // Security
  passwordChangedAt   DateTime        @default(now()) @db.Timestamptz(3)
  requirePasswordChange Boolean       @default(false)

  // Audit
  createdBy           String?         // AdminUser.id who created this
  createdAt           DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt           DateTime        @updatedAt @db.Timestamptz(3)
  deletedAt           DateTime?       @db.Timestamptz(3)

  // Relations
  sessions            AdminSession[]
  auditLogs           AdminAuditLog[]
  approvalRequests    ApprovalRequest[] @relation("Requester")
  approvalDecisions   ApprovalRequest[] @relation("Approver")
  notifications       AdminNotification[]
  webhooks            AdminWebhook[]

  @@index([email])
  @@index([username])
  @@index([role])
  @@index([isActive])
}

/// Permission: Granular permissions for role-based access
model Permission {
  id              String              @id @default(uuid())
  code            String              @unique    // e.g., "deployment:promote:testnet"
  name            String                         // Human-readable name
  description     String?
  category        PermissionCategory

  // Risk assessment
  riskLevel       RiskLevel           @default(LOW)
  requiresMfa     Boolean             @default(false)
  requiresApproval Boolean            @default(false)

  // Audit
  createdAt       DateTime            @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime            @updatedAt @db.Timestamptz(3)

  // Relations
  rolePermissions RolePermission[]

  @@index([category])
  @@index([riskLevel])
}

/// RolePermission: Maps permissions to roles (allows inheritance)
model RolePermission {
  id              String              @id @default(uuid())
  role            AdminRole
  permissionId    String

  // Override defaults
  canDelegate     Boolean             @default(false) // Can grant to others

  createdAt       DateTime            @default(now()) @db.Timestamptz(3)

  permission      Permission          @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([role, permissionId])
  @@index([role])
}

/// ApprovalRequest: Workflow for critical operations requiring SUPER_OWNER approval
model ApprovalRequest {
  id                String              @id @default(uuid())
  requestType       ApprovalType
  requesterId       String              // AdminUser.id

  // Request details
  action            String              // e.g., "promote:testnet:mainnet"
  targetResource    String?             // Resource being affected
  payload           Json?               // Additional context
  reason            String              // Why this action is needed

  // Approval token (cryptographically secure, time-limited)
  approvalToken     String?             @unique
  tokenExpiresAt    DateTime?           @db.Timestamptz(3)

  // Status tracking
  status            AdminApprovalStatus @default(PENDING)
  approverId        String?             // AdminUser.id of approver
  approvedAt        DateTime?           @db.Timestamptz(3)
  rejectedAt        DateTime?           @db.Timestamptz(3)
  rejectionReason   String?

  // Execution tracking
  executedAt        DateTime?           @db.Timestamptz(3)
  executionResult   Json?               // Result of the executed action

  // Audit
  createdAt         DateTime            @default(now()) @db.Timestamptz(3)
  updatedAt         DateTime            @updatedAt @db.Timestamptz(3)

  // Relations
  requester         AdminUser           @relation("Requester", fields: [requesterId], references: [id])
  approver          AdminUser?          @relation("Approver", fields: [approverId], references: [id])

  @@index([requesterId])
  @@index([approverId])
  @@index([status])
  @@index([requestType, status])
  @@index([tokenExpiresAt])
}

/// AdminSession: Tracks admin login sessions with idle timeout
model AdminSession {
  id                String              @id @default(uuid())
  adminId           String

  // Token management
  tokenHash         String              @unique  // SHA256 of JWT
  refreshTokenHash  String?             @unique

  // Session info
  ipAddress         String
  userAgent         String
  deviceFingerprint String?

  // Activity tracking (for idle timeout)
  lastActivityAt    DateTime            @default(now()) @db.Timestamptz(3)
  idleTimeoutMins   Int                 // 30 for ADMIN, 60 for SUPER_OWNER

  // Session lifecycle
  createdAt         DateTime            @default(now()) @db.Timestamptz(3)
  expiresAt         DateTime            @db.Timestamptz(3)
  revokedAt         DateTime?           @db.Timestamptz(3)
  revokeReason      String?

  // MFA state for session
  mfaVerifiedAt     DateTime?           @db.Timestamptz(3)

  admin             AdminUser           @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId])
  @@index([lastActivityAt])
  @@index([expiresAt])
}

/// AdminNotification: Notifications for admin users
model AdminNotification {
  id              String              @id @default(uuid())
  recipientId     String              // AdminUser.id
  type            NotificationType

  // Content
  title           String
  message         String

  // Action context
  actionUrl       String?             // Deep link within admin UI
  resourceType    String?             // e.g., "ApprovalRequest"
  resourceId      String?             // ID of related resource

  // Status
  status          NotificationStatus  @default(UNREAD)
  readAt          DateTime?           @db.Timestamptz(3)

  // Delivery tracking
  sentViaEmail    Boolean             @default(false)
  emailSentAt     DateTime?           @db.Timestamptz(3)
  sentViaWebhook  Boolean             @default(false)
  webhookSentAt   DateTime?           @db.Timestamptz(3)

  // Timestamps
  createdAt       DateTime            @default(now()) @db.Timestamptz(3)
  expiresAt       DateTime?           @db.Timestamptz(3)

  // Relations
  recipient       AdminUser           @relation(fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([recipientId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
}

/// AdminWebhook: Webhook endpoints for admin notifications
model AdminWebhook {
  id              String              @id @default(uuid())
  name            String              // Display name
  url             String              // Webhook endpoint URL
  secret          String              // HMAC signing secret

  // Event subscriptions (JSON array of event types)
  events          String[]            // e.g., ["ADMIN_APPROVAL_REQUESTED", "ADMIN_APPROVAL_APPROVED"]

  // Status
  isActive        Boolean             @default(true)

  // Metadata
  createdById     String              // AdminUser.id who created this
  headers         Json?               // Custom headers to include

  // Health tracking
  lastTriggeredAt DateTime?           @db.Timestamptz(3)
  lastSuccessAt   DateTime?           @db.Timestamptz(3)
  lastFailureAt   DateTime?           @db.Timestamptz(3)
  failureCount    Int                 @default(0)

  // Timestamps
  createdAt       DateTime            @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime            @updatedAt @db.Timestamptz(3)

  // Relations
  createdBy       AdminUser           @relation(fields: [createdById], references: [id])
  deliveries      WebhookDelivery[]

  @@index([isActive])
  @@index([createdById])
}

/// WebhookDelivery: Tracks individual webhook delivery attempts
model WebhookDelivery {
  id              String              @id @default(uuid())
  webhookId       String

  // Event data
  eventType       String
  payload         Json

  // Delivery attempt
  status          String              @default("PENDING") // PENDING, SUCCESS, FAILED
  httpStatus      Int?
  response        String?             @db.Text
  error           String?

  // Retry tracking
  attempts        Int                 @default(0)
  nextRetryAt     DateTime?           @db.Timestamptz(3)

  // Timestamps
  createdAt       DateTime            @default(now()) @db.Timestamptz(3)
  deliveredAt     DateTime?           @db.Timestamptz(3)

  // Relations
  webhook         AdminWebhook        @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  @@index([webhookId])
  @@index([status])
  @@index([nextRetryAt])
}

/// AdminAuditLog: Immutable audit trail for all admin actions
model AdminAuditLog {
  id                String              @id @default(uuid())
  adminId           String

  // Event details
  action            String              // e.g., "user:approve", "deployment:promote"
  category          PermissionCategory
  resourceType      String?             // e.g., "UserProfile", "Deployment"
  resourceId        String?

  // Context
  ipAddress         String
  userAgent         String
  sessionId         String?

  // Data
  previousValue     Json?               // Before state
  newValue          Json?               // After state
  metadata          Json?               // Additional context

  // Request tracking
  requestId         String?             // For tracing
  approvalRequestId String?             // If action required approval

  // Security - Tamper detection
  eventHash         String              // SHA256(id + action + timestamp + previousHash)
  previousHash      String?             // Chain to previous audit entry

  // Timestamp
  timestamp         DateTime            @default(now()) @db.Timestamptz(3)

  admin             AdminUser           @relation(fields: [adminId], references: [id])

  @@index([adminId])
  @@index([action])
  @@index([category])
  @@index([resourceType, resourceId])
  @@index([timestamp])
  @@index([requestId])
}

/// RbacConfig: Global RBAC configuration settings
model RbacConfig {
  id                        String    @id @default("default")

  // Session timeouts (in minutes)
  adminIdleTimeoutMins      Int       @default(30)
  superOwnerIdleTimeoutMins Int       @default(60)
  maxSessionDurationHours   Int       @default(24)

  // Approval settings
  approvalTokenValidityMins Int       @default(30)    // 30 mins for banking ops
  maxPendingApprovals       Int       @default(10)    // Per requester

  // Password policy
  minPasswordLength         Int       @default(12)
  requireUppercase          Boolean   @default(true)
  requireLowercase          Boolean   @default(true)
  requireNumbers            Boolean   @default(true)
  requireSpecialChars       Boolean   @default(true)
  passwordExpiryDays        Int       @default(90)

  // Lockout policy
  maxLoginAttempts          Int       @default(5)
  lockoutDurationMins       Int       @default(30)

  // MFA settings
  requireMfaForAllAdmins    Boolean   @default(false)
  mfaTotpIssuer             String    @default("GXCoin Admin")

  updatedAt                 DateTime  @updatedAt @db.Timestamptz(3)
  updatedBy                 String?   // AdminUser.id
}

// =============================================================================
// SECTION 16: Q SEND - QR-BASED PAYMENT REQUEST SYSTEM
// Dynamic payment requests with 5-minute validity (OTP-like)
// =============================================================================

/// QSendStatus: Lifecycle states for Q Send payment requests
enum QSendStatus {
  ACTIVE          // QR code is valid and awaiting payment
  PAID            // Payment has been completed
  EXPIRED         // 5-minute validity period has passed
  CANCELLED       // Request was cancelled by the creator
}

/// QSendRequest: Dynamic QR-based payment request
/// Creator generates a request, shares QR code, and payer scans to pay
model QSendRequest {
  id                String          @id @default(uuid())
  tenantId          String

  // Request Identification
  requestCode       String          @unique  // Short unique code (e.g., "QS-A1B2C3D4")
  qrData            String          // Encoded QR payload (JSON with all request details)
  qrHash            String          // SHA256 of qrData for integrity verification

  // Creator (who wants to receive payment)
  creatorProfileId  String          // UserProfile.id of requester
  creatorWalletId   String          // Wallet to receive funds

  // Payment Details
  amount            Decimal         @db.Decimal(36, 9)  // Fixed amount in GX Coins
  description       String?         // Purpose/reason for payment (max 200 chars)
  reference         String?         // Optional external reference (invoice #, order #)

  // Validity Period (OTP-like 5-minute window)
  createdAt         DateTime        @default(now()) @db.Timestamptz(3)
  expiresAt         DateTime        @db.Timestamptz(3)  // createdAt + 5 minutes
  validitySeconds   Int             @default(300)       // Default 5 mins (300 seconds)

  // Status Tracking
  status            QSendStatus     @default(ACTIVE)
  statusChangedAt   DateTime?       @db.Timestamptz(3)

  // Payer Information (filled when scanned/paid)
  payerProfileId    String?         // UserProfile.id of payer (set when paid)
  payerWalletId     String?         // Wallet used for payment

  // Payment Completion
  paidAt            DateTime?       @db.Timestamptz(3)
  outboxCommandId   String?         // Reference to OutboxCommand for the transfer
  onChainTxId       String?         // Fabric transaction ID

  // Receipt/Acknowledgement
  receiptSentAt     DateTime?       @db.Timestamptz(3)  // When receipt was sent to payer
  receiptData       Json?           // Receipt details (amount, time, parties, etc.)

  // Metadata
  ipAddress         String?         // IP where QR was generated
  userAgent         String?         // Device/browser info
  scannedCount      Int             @default(0)  // Number of times QR was scanned
  lastScannedAt     DateTime?       @db.Timestamptz(3)

  // Relations
  creator           UserProfile     @relation("QSendCreator", fields: [creatorProfileId], references: [profileId], onDelete: Cascade)
  payer             UserProfile?    @relation("QSendPayer", fields: [payerProfileId], references: [profileId], onDelete: SetNull)

  @@index([tenantId, creatorProfileId])
  @@index([tenantId, status])
  @@index([tenantId, expiresAt])
  @@index([requestCode])
  @@index([qrHash])
  @@index([createdAt])
  @@index([status, expiresAt])
}

/// QSendDashboardView: Aggregated statistics for Q Send dashboard
/// This is a materialized view pattern - updated periodically or on-demand
model QSendStats {
  id                String          @id @default(uuid())
  tenantId          String
  profileId         String          // UserProfile.id

  // Period (for historical tracking)
  periodStart       DateTime        @db.Date
  periodEnd         DateTime        @db.Date
  periodType        String          // "daily", "weekly", "monthly", "all_time"

  // Request Statistics
  totalRequests     Int             @default(0)
  activeRequests    Int             @default(0)
  paidRequests      Int             @default(0)
  expiredRequests   Int             @default(0)
  cancelledRequests Int             @default(0)

  // Payment Statistics
  totalAmountRequested  Decimal     @default(0) @db.Decimal(36, 9)
  totalAmountReceived   Decimal     @default(0) @db.Decimal(36, 9)
  avgPaymentTime        Int?        // Average seconds from creation to payment

  // Timestamps
  calculatedAt      DateTime        @default(now()) @db.Timestamptz(3)

  @@unique([tenantId, profileId, periodType, periodStart])
  @@index([tenantId, profileId])
  @@index([periodType])
}

// =============================================================================
// SECTION 17: PHASE 1 - WALLET ENHANCEMENT FEATURES
// Context Switching, Sub-Accounts, Categories, Receipts, Contact Groups, Analytics
// =============================================================================

/// ContextType: Distinguishes between personal and business wallet contexts
enum ContextType {
  PERSONAL
  BUSINESS
  GOVERNMENT      // Government agency/department account
  NOT_FOR_PROFIT  // Non-profit organization/charity account
}

/// AccountContext: Enables SSO switching between personal, business, government, and NPO wallets
/// Users can have one personal context and multiple entity contexts (business, government, NPO)
model AccountContext {
  id              String          @id @default(uuid())
  tenantId        String
  profileId       String          // UserProfile.id

  // Context identification
  type            ContextType
  businessAccountId     String?   // For type=BUSINESS
  governmentAccountId   String?   // For type=GOVERNMENT
  npoAccountId          String?   // For type=NOT_FOR_PROFIT
  name            String          // Display name: "Personal Wallet" or entity name
  icon            String?         // Custom icon identifier

  // State
  isDefault       Boolean         @default(false)
  isActive        Boolean         @default(true)
  lastAccessedAt  DateTime?       @db.Timestamptz(3)

  // Timestamps
  createdAt       DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime        @updatedAt @db.Timestamptz(3)

  // Relations
  userProfile       UserProfile          @relation(fields: [profileId], references: [profileId], onDelete: Cascade)
  businessAccount   BusinessAccount?     @relation(fields: [businessAccountId], references: [businessAccountId], onDelete: Cascade)
  governmentAccount GovernmentAccount?   @relation(fields: [governmentAccountId], references: [governmentAccountId], onDelete: Cascade)
  npoAccount        NotForProfitAccount? @relation(fields: [npoAccountId], references: [npoAccountId], onDelete: Cascade)

  // Unique constraint: One context per type per entity per user
  // For PERSONAL: businessAccountId, governmentAccountId, npoAccountId are all null
  // For others: exactly one of the IDs should be set
  @@unique([tenantId, profileId, type, businessAccountId, governmentAccountId, npoAccountId])
  @@index([tenantId, profileId])
  @@index([tenantId, profileId, isDefault])
  @@index([tenantId, type])
}

/// SubAccountType: Types of sub-accounts for budgeting
enum SubAccountType {
  // Personal sub-accounts
  SAVINGS
  EMERGENCY_FUND
  MORTGAGE
  RENT
  UTILITIES
  GROCERIES
  ENTERTAINMENT
  HEALTHCARE
  EDUCATION
  VACATION
  CUSTOM_PERSONAL

  // Business sub-accounts
  PAYROLL
  OPERATING_EXPENSES
  TAX_RESERVE
  MARKETING
  EQUIPMENT
  INVENTORY
  DEPARTMENT
  PROJECT
  CUSTOM_BUSINESS
}

/// SubAccount: Virtual divisions of a wallet for budgeting
/// Balances are tracked off-chain while main wallet holds actual funds on blockchain
model SubAccount {
  id              String          @id @default(uuid())
  tenantId        String
  walletId        String          // Parent wallet
  contextId       String?         // Optional link to AccountContext

  // Display
  name            String
  description     String?
  type            SubAccountType
  icon            String?
  color           String?         // Hex color code

  // Balance tracking (virtual, not on-chain)
  currentBalance  Decimal         @default(0) @db.Decimal(36, 9)
  reservedBalance Decimal         @default(0) @db.Decimal(36, 9)  // Pending allocations

  // Budget configuration
  monthlyBudget   Decimal?        @db.Decimal(36, 9)
  monthlySpent    Decimal         @default(0) @db.Decimal(36, 9)
  monthlyResetDay Int             @default(1)  // 1-28

  // Goal tracking
  goalAmount      Decimal?        @db.Decimal(36, 9)
  goalDeadline    DateTime?       @db.Timestamptz(3)
  goalName        String?

  // State
  isActive        Boolean         @default(true)
  sortOrder       Int             @default(0)

  // Timestamps
  createdAt       DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime        @updatedAt @db.Timestamptz(3)

  // Relations
  wallet          Wallet          @relation(fields: [walletId], references: [walletId], onDelete: Cascade)
  allocations     AllocationRule[]
  transactions    SubAccountTransaction[]
  budgetPeriods   BudgetPeriod[]

  @@unique([tenantId, walletId, name])
  @@index([tenantId, walletId])
  @@index([tenantId, walletId, isActive])
}

/// AllocationRuleType: How allocation amounts are calculated
enum AllocationRuleType {
  PERCENTAGE      // Percentage of incoming amount
  FIXED_AMOUNT    // Fixed amount per trigger
  REMAINDER       // Whatever is left after other rules
}

/// AllocationTrigger: When allocations should execute
enum AllocationTrigger {
  ON_RECEIVE      // When wallet receives funds
  ON_SCHEDULE     // Scheduled (daily/weekly/monthly)
  MANUAL          // Manual trigger only
}

/// AllocationFrequency: Frequency for scheduled allocations
enum AllocationFrequency {
  DAILY
  WEEKLY
  BI_WEEKLY
  MONTHLY
  QUARTERLY
}

/// AllocationRule: Automatic fund distribution to sub-accounts
model AllocationRule {
  id              String              @id @default(uuid())
  tenantId        String
  walletId        String
  subAccountId    String

  // Rule name
  name            String
  description     String?

  // Rule configuration
  ruleType        AllocationRuleType
  percentage      Decimal?            @db.Decimal(5, 2)  // For PERCENTAGE type (0-100)
  fixedAmount     Decimal?            @db.Decimal(36, 9) // For FIXED_AMOUNT type

  // Trigger configuration
  triggerType     AllocationTrigger
  minTriggerAmount Decimal?           @db.Decimal(36, 9) // Minimum amount to trigger

  // Scheduling (for ON_SCHEDULE trigger)
  frequency       AllocationFrequency?
  dayOfMonth      Int?                // 1-28 for monthly
  dayOfWeek       Int?                // 0-6 for weekly (0=Sunday)
  nextScheduledAt DateTime?           @db.Timestamptz(3)
  lastExecutedAt  DateTime?           @db.Timestamptz(3)

  // State
  isActive        Boolean             @default(true)
  priority        Int                 @default(0)  // Higher priority executes first

  // Timestamps
  createdAt       DateTime            @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime            @updatedAt @db.Timestamptz(3)

  // Relations
  wallet          Wallet              @relation(fields: [walletId], references: [walletId], onDelete: Cascade)
  subAccount      SubAccount          @relation(fields: [subAccountId], references: [id], onDelete: Cascade)
  executions      AllocationExecution[]

  @@unique([tenantId, walletId, name])
  @@index([tenantId, walletId])
  @@index([tenantId, isActive])
  @@index([triggerType, isActive])
  @@index([nextScheduledAt])
}

/// AllocationExecution: Log of allocation rule executions
model AllocationExecution {
  id              String          @id @default(uuid())
  tenantId        String
  ruleId          String
  subAccountId    String

  // Execution details
  amount          Decimal         @db.Decimal(36, 9)
  triggerAmount   Decimal?        @db.Decimal(36, 9)  // Amount that triggered allocation
  triggeredBy     String?         // "ON_RECEIVE", "SCHEDULED", "MANUAL"

  // Source transaction (for ON_RECEIVE)
  sourceTransactionId String?

  // Status
  status          String          @default("COMPLETED")  // COMPLETED, FAILED, REVERSED
  errorMessage    String?

  // Timestamps
  executedAt      DateTime        @default(now()) @db.Timestamptz(3)

  // Relations
  rule            AllocationRule  @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@index([tenantId, ruleId])
  @@index([tenantId, subAccountId])
  @@index([executedAt])
}

/// SubAccountTxType: Types of sub-account transactions
enum SubAccountTxType {
  ALLOCATION       // Auto or manual allocation from main wallet
  TRANSFER_IN      // Transfer from another sub-account
  TRANSFER_OUT     // Transfer to another sub-account
  SPEND            // Payment from sub-account
  RETURN_TO_MAIN   // Return funds to main wallet
  ADJUSTMENT       // Manual adjustment
}

/// SubAccountTransaction: Tracks movements within sub-accounts
model SubAccountTransaction {
  id              String          @id @default(uuid())
  tenantId        String
  subAccountId    String
  mainTransactionId String?       // Link to main Transaction if applicable

  // Transaction details
  type            SubAccountTxType
  amount          Decimal         @db.Decimal(36, 9)
  balanceBefore   Decimal         @db.Decimal(36, 9)
  balanceAfter    Decimal         @db.Decimal(36, 9)

  // For transfers between sub-accounts
  counterpartSubAccountId String?
  isCredit        Boolean         // true = money in, false = money out

  // Description
  description     String?
  reference       String?

  // Timestamps
  createdAt       DateTime        @default(now()) @db.Timestamptz(3)

  // Relations
  subAccount      SubAccount      @relation(fields: [subAccountId], references: [id], onDelete: Cascade)
  mainTransaction Transaction?    @relation(fields: [mainTransactionId], references: [offTxId], onDelete: SetNull)

  @@index([tenantId, subAccountId])
  @@index([tenantId, subAccountId, createdAt])
  @@index([mainTransactionId])
}

/// BudgetPeriodType: Types of budget periods
enum BudgetPeriodType {
  WEEKLY
  MONTHLY
  QUARTERLY
  YEARLY
  CUSTOM
}

/// BudgetStatus: Status of a budget period
enum BudgetStatus {
  ON_TRACK         // Spending within limits
  WARNING          // Above alert threshold
  EXCEEDED         // Over budget
  COMPLETED        // Period ended
}

/// BudgetPeriod: Tracks budget performance over a period
model BudgetPeriod {
  id              String          @id @default(uuid())
  tenantId        String
  walletId        String
  subAccountId    String?         // null for overall wallet budget

  // Period definition
  periodType      BudgetPeriodType
  startDate       DateTime        @db.Timestamptz(3)
  endDate         DateTime        @db.Timestamptz(3)

  // Budget amounts
  budgetAmount    Decimal         @db.Decimal(36, 9)
  spentAmount     Decimal         @default(0) @db.Decimal(36, 9)
  remainingAmount Decimal         @db.Decimal(36, 9)

  // Status
  status          BudgetStatus    @default(ON_TRACK)
  alertThreshold  Decimal         @default(80) @db.Decimal(5, 2)  // Percentage
  alertSent       Boolean         @default(false)
  alertSentAt     DateTime?       @db.Timestamptz(3)

  // Timestamps
  createdAt       DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime        @updatedAt @db.Timestamptz(3)

  // Relations
  wallet          Wallet          @relation(fields: [walletId], references: [walletId], onDelete: Cascade)
  subAccount      SubAccount?     @relation(fields: [subAccountId], references: [id], onDelete: Cascade)

  @@unique([tenantId, walletId, subAccountId, periodType, startDate])
  @@index([tenantId, walletId])
  @@index([tenantId, status])
  @@index([endDate])
}

/// TransactionCategory: User-defined categories for transaction tagging
model TransactionCategory {
  id              String          @id @default(uuid())
  tenantId        String
  profileId       String          // Owner of this category

  // Category details
  name            String
  description     String?
  color           String          @default("#6366F1")  // Hex color
  icon            String?         // Icon identifier

  // Type
  isSystem        Boolean         @default(false)  // System-defined (non-deletable)
  isIncome        Boolean         @default(false)  // Income vs expense category

  // State
  isActive        Boolean         @default(true)
  sortOrder       Int             @default(0)

  // Timestamps
  createdAt       DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime        @updatedAt @db.Timestamptz(3)

  // Relations
  userProfile     UserProfile     @relation(fields: [profileId], references: [profileId], onDelete: Cascade)
  tags            TransactionTag[]

  @@unique([tenantId, profileId, name])
  @@index([tenantId, profileId])
  @@index([tenantId, profileId, isActive])
}

/// TransactionTag: Links transactions to categories
model TransactionTag {
  id              String              @id @default(uuid())
  tenantId        String
  transactionId   String
  categoryId      String

  // Optional notes
  notes           String?

  // Timestamps
  createdAt       DateTime            @default(now()) @db.Timestamptz(3)

  // Relations
  transaction     Transaction         @relation(fields: [transactionId], references: [offTxId], onDelete: Cascade)
  category        TransactionCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([tenantId, transactionId, categoryId])
  @@index([tenantId, transactionId])
  @@index([tenantId, categoryId])
}

/// TransactionReceipt: Downloadable receipts for transactions
model TransactionReceipt {
  id              String          @id @default(uuid())
  tenantId        String
  transactionId   String          @unique

  // Receipt identification
  receiptNumber   String          @unique  // Format: RCP-YYYYMMDD-XXXXX
  receiptHash     String          // SHA256 for integrity

  // Receipt data (snapshot at generation time)
  data            Json            // Full transaction details

  // File storage
  pdfUrl          String?         // S3/storage URL
  pdfGeneratedAt  DateTime?       @db.Timestamptz(3)

  // Sharing
  shareableLink   String?         @unique  // Short link for sharing
  shareExpiresAt  DateTime?       @db.Timestamptz(3)
  downloadCount   Int             @default(0)

  // Timestamps
  createdAt       DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime        @updatedAt @db.Timestamptz(3)

  // Relations
  transaction     Transaction     @relation(fields: [transactionId], references: [offTxId], onDelete: Cascade)

  @@index([tenantId])
  @@index([receiptNumber])
}

/// ContactGroupType: Types of contact groups
enum ContactGroupType {
  FAMILY            // Auto-created from relationships
  CLOSE_FRIENDS
  PROFESSIONAL
  CUSTOM
}

/// ContactGroup: Groups for organizing contacts
model ContactGroup {
  id              String          @id @default(uuid())
  tenantId        String
  profileId       String          // Owner

  // Group details
  name            String
  description     String?
  type            ContactGroupType
  color           String?
  icon            String?

  // State
  isSystem        Boolean         @default(false)  // Auto-created groups
  sortOrder       Int             @default(0)

  // Timestamps
  createdAt       DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime        @updatedAt @db.Timestamptz(3)

  // Relations
  userProfile     UserProfile     @relation(fields: [profileId], references: [profileId], onDelete: Cascade)
  members         ContactGroupMember[]

  @@unique([tenantId, profileId, name])
  @@index([tenantId, profileId])
  @@index([tenantId, profileId, type])
}

/// ContactGroupMember: Links contacts to groups
model ContactGroupMember {
  id              String          @id @default(uuid())
  tenantId        String
  groupId         String
  contactId       String

  // Timestamps
  addedAt         DateTime        @default(now()) @db.Timestamptz(3)

  // Relations
  group           ContactGroup    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  contact         Contact         @relation(fields: [contactId], references: [contactId], onDelete: Cascade)

  @@unique([tenantId, groupId, contactId])
  @@index([tenantId, groupId])
  @@index([tenantId, contactId])
}

/// CoinRequestStatus: Status of coin request
enum CoinRequestStatus {
  PENDING
  FULFILLED
  EXPIRED
  CANCELLED
  DECLINED
}

/// CoinRequest: Request coins from another user (enhanced payment request)
model CoinRequest {
  id              String              @id @default(uuid())
  tenantId        String

  // Request identification
  requestCode     String              @unique  // Short code: REQ-XXXXXX

  // Parties
  requesterId     String              // Who is asking for coins
  requesterWalletId String
  requesteeId     String?             // Specific person (null = open request)
  requesteeEmail  String?             // Or by email
  requesteePhone  String?             // Or by phone

  // Request details
  amount          Decimal             @db.Decimal(36, 9)
  currency        String              @default("GXC")
  reason          String?             // Why requesting
  reference       String?             // External reference

  // QR Code
  qrData          String              // Encoded QR payload
  qrHash          String              // Integrity hash

  // Validity
  expiresAt       DateTime            @db.Timestamptz(3)
  validityHours   Int                 @default(24)

  // Status
  status          CoinRequestStatus   @default(PENDING)
  statusChangedAt DateTime?           @db.Timestamptz(3)

  // Fulfillment
  fulfilledBy     String?             // Who paid
  fulfilledAt     DateTime?           @db.Timestamptz(3)
  transactionId   String?             // Resulting transaction

  // Decline
  declinedAt      DateTime?           @db.Timestamptz(3)
  declineReason   String?

  // Timestamps
  createdAt       DateTime            @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime            @updatedAt @db.Timestamptz(3)

  // Relations
  requester       UserProfile         @relation("CoinRequester", fields: [requesterId], references: [profileId], onDelete: Cascade)
  requestee       UserProfile?        @relation("CoinRequestee", fields: [requesteeId], references: [profileId], onDelete: SetNull)

  @@index([tenantId, requesterId])
  @@index([tenantId, requesteeId])
  @@index([tenantId, status])
  @@index([requestCode])
  @@index([expiresAt])
}

/// DailyAnalytics: Daily aggregated analytics per wallet
model DailyAnalytics {
  id              String          @id @default(uuid())
  tenantId        String
  profileId       String
  walletId        String

  // Date
  date            DateTime        @db.Date

  // Transaction metrics
  totalSent       Decimal         @default(0) @db.Decimal(36, 9)
  totalReceived   Decimal         @default(0) @db.Decimal(36, 9)
  netFlow         Decimal         @default(0) @db.Decimal(36, 9)
  sendCount       Int             @default(0)
  receiveCount    Int             @default(0)

  // Fees
  totalFees       Decimal         @default(0) @db.Decimal(36, 9)

  // Balance snapshot
  openingBalance  Decimal         @db.Decimal(36, 9)
  closingBalance  Decimal         @db.Decimal(36, 9)

  // Category breakdown (JSON for flexibility)
  categoryBreakdown Json?         // { "categoryId": { "sent": 100, "received": 50 } }

  // Sub-account summary
  subAccountSummary Json?         // { "subAccountId": { "allocated": 100, "spent": 50 } }

  // Timestamps
  createdAt       DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime        @updatedAt @db.Timestamptz(3)

  // Relations
  userProfile     UserProfile     @relation(fields: [profileId], references: [profileId], onDelete: Cascade)
  wallet          Wallet          @relation(fields: [walletId], references: [walletId], onDelete: Cascade)

  @@unique([tenantId, profileId, walletId, date])
  @@index([tenantId, profileId, date])
  @@index([tenantId, walletId, date])
}

/// MonthlyAnalytics: Monthly aggregated analytics per wallet
model MonthlyAnalytics {
  id              String          @id @default(uuid())
  tenantId        String
  profileId       String
  walletId        String

  // Period
  year            Int
  month           Int             // 1-12

  // Transaction metrics
  totalSent       Decimal         @default(0) @db.Decimal(36, 9)
  totalReceived   Decimal         @default(0) @db.Decimal(36, 9)
  netFlow         Decimal         @default(0) @db.Decimal(36, 9)
  sendCount       Int             @default(0)
  receiveCount    Int             @default(0)

  // Fees
  totalFees       Decimal         @default(0) @db.Decimal(36, 9)

  // Balance
  avgDailyBalance Decimal         @default(0) @db.Decimal(36, 9)
  minBalance      Decimal         @db.Decimal(36, 9)
  maxBalance      Decimal         @db.Decimal(36, 9)

  // Trends (compared to previous month)
  sentTrend       Decimal?        @db.Decimal(10, 2)    // Percentage change
  receiveTrend    Decimal?        @db.Decimal(10, 2)

  // Breakdowns
  categoryBreakdown Json?
  subAccountSummary Json?

  // Budget tracking
  budgetAmount    Decimal?        @db.Decimal(36, 9)
  budgetUsed      Decimal?        @db.Decimal(10, 2)    // Percentage

  // Timestamps
  createdAt       DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime        @updatedAt @db.Timestamptz(3)

  // Relations
  userProfile     UserProfile     @relation(fields: [profileId], references: [profileId], onDelete: Cascade)
  wallet          Wallet          @relation(fields: [walletId], references: [walletId], onDelete: Cascade)

  @@unique([tenantId, profileId, walletId, year, month])
  @@index([tenantId, profileId, year, month])
  @@index([tenantId, walletId, year, month])
}

// =============================================================================
// PHASE 3: BUSINESS & ENTERPRISE FEATURES
// =============================================================================

/// BusinessSubAccountType: Types of business sub-accounts
enum BusinessSubAccountType {
  PAYROLL
  OPERATING_EXPENSES
  TAX_RESERVE
  MARKETING
  SALES
  R_AND_D
  EQUIPMENT
  INVENTORY
  DEPARTMENT
  PROJECT
  CLIENT_ESCROW
  VENDOR_PAYMENTS
  CUSTOM_BUSINESS
}

/// BusinessSubAccount: Virtual fund allocations for business accounts
model BusinessSubAccount {
  id                String          @id @default(uuid())
  tenantId          String
  businessAccountId String
  name              String
  description       String?
  type              BusinessSubAccountType

  // Department/Project specific
  departmentId      String?
  projectId         String?
  costCenter        String?         // For accounting integration

  // Budget allocation
  annualBudget      Decimal?        @db.Decimal(36, 9)
  monthlyBudget     Decimal?        @db.Decimal(36, 9)
  currentBalance    Decimal         @default(0) @db.Decimal(36, 9)

  // Approval requirements
  requiresApproval  Boolean         @default(false)
  approvalThreshold Decimal?        @db.Decimal(36, 9)  // Require approval above this amount

  // Access control
  managerId         String?         // UserProfile ID who manages this sub-account
  allowedUserIds    String[]        // UserProfile IDs who can transact

  // UI customization
  icon              String?
  color             String?
  sortOrder         Int             @default(0)

  // Status
  isActive          Boolean         @default(true)
  createdAt         DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt         DateTime        @updatedAt @db.Timestamptz(3)

  // Relations
  businessAccount   BusinessAccount @relation(fields: [businessAccountId], references: [businessAccountId], onDelete: Cascade)
  transactions      BusinessSubAccountTx[]
  budgetPeriods     BusinessBudgetPeriod[]

  @@unique([tenantId, businessAccountId, name])
  @@index([tenantId, businessAccountId])
  @@index([tenantId, businessAccountId, type])
}

/// BusinessSubAccountTxType: Types of business sub-account transactions
enum BusinessSubAccountTxType {
  ALLOCATION
  EXPENSE
  RETURN_TO_MAIN
  TRANSFER_IN
  TRANSFER_OUT
  PAYROLL_PAYMENT
  VENDOR_PAYMENT
  ADJUSTMENT
}

/// BusinessSubAccountTx: Transactions within business sub-accounts
model BusinessSubAccountTx {
  id                String          @id @default(uuid())
  tenantId          String
  businessSubAccountId String
  type              BusinessSubAccountTxType
  amount            Decimal         @db.Decimal(36, 9)
  description       String?
  reference         String?         // External reference (invoice, PO, etc.)

  // Related entities
  employeeId        String?         // For payroll payments
  vendorName        String?         // For vendor payments

  // Balance tracking
  balanceBefore     Decimal         @db.Decimal(36, 9)
  balanceAfter      Decimal         @db.Decimal(36, 9)

  // Approval tracking
  approvedById      String?
  approvedAt        DateTime?       @db.Timestamptz(3)

  createdAt         DateTime        @default(now()) @db.Timestamptz(3)
  createdById       String

  // Relations
  businessSubAccount BusinessSubAccount @relation(fields: [businessSubAccountId], references: [id], onDelete: Cascade)
  employee          Employee?       @relation(fields: [employeeId], references: [id])

  @@index([tenantId, businessSubAccountId])
  @@index([tenantId, businessSubAccountId, createdAt])
  @@index([tenantId, employeeId])
}

/// BusinessBudgetPeriod: Budget periods for business sub-accounts
model BusinessBudgetPeriod {
  id                String          @id @default(uuid())
  tenantId          String
  businessSubAccountId String
  periodType        BudgetPeriodType
  startDate         DateTime        @db.Timestamptz(3)
  endDate           DateTime        @db.Timestamptz(3)

  budgetAmount      Decimal         @db.Decimal(36, 9)
  spentAmount       Decimal         @default(0) @db.Decimal(36, 9)
  remainingAmount   Decimal         @db.Decimal(36, 9)

  status            BudgetStatus    @default(ON_TRACK)
  alertThreshold    Decimal         @default(80) @db.Decimal(5, 2)
  alertSent         Boolean         @default(false)
  alertSentAt       DateTime?       @db.Timestamptz(3)

  createdAt         DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt         DateTime        @updatedAt @db.Timestamptz(3)

  // Relations
  businessSubAccount BusinessSubAccount @relation(fields: [businessSubAccountId], references: [id], onDelete: Cascade)

  @@index([tenantId, businessSubAccountId])
  @@index([tenantId, businessSubAccountId, startDate, endDate])
}

/// PaymentMethod: How employees are paid
enum PaymentMethod {
  DIRECT_TRANSFER
  BATCH_PAYROLL
  MANUAL
}

/// PaymentSchedule: Frequency of payment
enum PaymentSchedule {
  WEEKLY
  BI_WEEKLY
  SEMI_MONTHLY
  MONTHLY
}

/// Employee: Employee records for business accounts
model Employee {
  id                String          @id @default(uuid())
  tenantId          String
  businessAccountId String
  userId            String?         // Links to UserProfile if they have a GX account

  // Employee details
  employeeNumber    String          // Internal employee ID/number
  firstName         String
  lastName          String
  email             String
  phone             String?
  title             String
  department        String?

  // Employment dates
  startDate         DateTime        @db.Timestamptz(3)
  endDate           DateTime?       @db.Timestamptz(3)

  // Payment configuration
  paymentMethod     PaymentMethod   @default(DIRECT_TRANSFER)
  paymentSchedule   PaymentSchedule @default(MONTHLY)
  salaryAmount      Decimal?        @db.Decimal(36, 9)
  hourlyRate        Decimal?        @db.Decimal(20, 4)
  currency          String          @default("GXC")

  // Payment destination
  walletId          String?         // GX Wallet ID for payments
  externalAccount   String?         // External account info if not using GX

  // Sub-account access
  allowedSubAccountIds String[]     // BusinessSubAccount IDs employee can access

  // Status
  isActive          Boolean         @default(true)
  createdAt         DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt         DateTime        @updatedAt @db.Timestamptz(3)

  // Relations
  businessAccount   BusinessAccount @relation(fields: [businessAccountId], references: [businessAccountId], onDelete: Cascade)
  user              UserProfile?    @relation(fields: [userId], references: [profileId])
  payrollRecords    PayrollRecord[]
  subAccountTxs     BusinessSubAccountTx[]

  @@unique([tenantId, businessAccountId, employeeNumber])
  @@unique([tenantId, businessAccountId, email])
  @@index([tenantId, businessAccountId])
  @@index([tenantId, businessAccountId, isActive])
}

/// PayrollStatus: Status of a payroll record
enum PayrollStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  PROCESSING
  PAID
  FAILED
  CANCELLED
}

/// PayrollRecord: Individual payroll payment records
model PayrollRecord {
  id                String          @id @default(uuid())
  tenantId          String
  employeeId        String
  payrollBatchId    String?         // Links to batch if part of batch payroll

  // Period
  periodStart       DateTime        @db.Timestamptz(3)
  periodEnd         DateTime        @db.Timestamptz(3)

  // Amounts
  grossAmount       Decimal         @db.Decimal(36, 9)
  deductions        Decimal         @default(0) @db.Decimal(36, 9)
  bonuses           Decimal         @default(0) @db.Decimal(36, 9)
  netAmount         Decimal         @db.Decimal(36, 9)

  // Breakdown (JSON for flexibility)
  deductionBreakdown Json?          // { "tax": 100, "insurance": 50, ... }
  bonusBreakdown    Json?           // { "performance": 200, "holiday": 100, ... }

  // Status tracking
  status            PayrollStatus   @default(DRAFT)
  approvedById      String?
  approvedAt        DateTime?       @db.Timestamptz(3)
  transactionId     String?         // GX Transaction ID when paid
  paidAt            DateTime?       @db.Timestamptz(3)
  failureReason     String?

  // Notes
  notes             String?

  createdAt         DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt         DateTime        @updatedAt @db.Timestamptz(3)
  createdById       String

  // Relations
  employee          Employee        @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  payrollBatch      PayrollBatch?   @relation(fields: [payrollBatchId], references: [id])

  @@index([tenantId, employeeId])
  @@index([tenantId, employeeId, periodStart])
  @@index([tenantId, payrollBatchId])
  @@index([tenantId, status])
}

/// PayrollBatch: Batch payroll processing
model PayrollBatch {
  id                String          @id @default(uuid())
  tenantId          String
  businessAccountId String
  name              String          // e.g., "December 2025 Payroll"

  // Period
  periodStart       DateTime        @db.Timestamptz(3)
  periodEnd         DateTime        @db.Timestamptz(3)

  // Totals
  totalEmployees    Int
  totalGrossAmount  Decimal         @db.Decimal(36, 9)
  totalDeductions   Decimal         @default(0) @db.Decimal(36, 9)
  totalNetAmount    Decimal         @db.Decimal(36, 9)

  // Status
  status            PayrollStatus   @default(DRAFT)
  approvedById      String?
  approvedAt        DateTime?       @db.Timestamptz(3)
  processedAt       DateTime?       @db.Timestamptz(3)
  completedAt       DateTime?       @db.Timestamptz(3)

  // Source sub-account
  sourceSubAccountId String?        // BusinessSubAccount to pay from

  // Notes
  notes             String?

  createdAt         DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt         DateTime        @updatedAt @db.Timestamptz(3)
  createdById       String

  // Relations
  businessAccount   BusinessAccount @relation(fields: [businessAccountId], references: [businessAccountId], onDelete: Cascade)
  payrollRecords    PayrollRecord[]

  @@index([tenantId, businessAccountId])
  @@index([tenantId, businessAccountId, periodStart])
  @@index([tenantId, status])
}

/// BusinessReportType: Types of business reports
enum BusinessReportType {
  DAILY_SUMMARY
  WEEKLY_SUMMARY
  MONTHLY_PROFIT_LOSS
  QUARTERLY_REPORT
  ANNUAL_REPORT
  TAX_SUMMARY
  PAYROLL_REPORT
  EXPENSE_REPORT
  BUDGET_VS_ACTUAL
  CUSTOM
}

/// BusinessReport: Generated business reports
model BusinessReport {
  id                String          @id @default(uuid())
  tenantId          String
  businessAccountId String

  // Report configuration
  reportType        BusinessReportType
  name              String
  periodStart       DateTime        @db.Timestamptz(3)
  periodEnd         DateTime        @db.Timestamptz(3)

  // Aggregated data
  totalIncome       Decimal         @db.Decimal(36, 9)
  totalExpenses     Decimal         @db.Decimal(36, 9)
  netProfit         Decimal         @db.Decimal(36, 9)

  // Detailed breakdown (JSON)
  incomeByCategory  Json?           // { "category": amount }
  expensesByCategory Json?          // { "category": amount }
  subAccountSummary Json?           // { "subAccountId": { "budget": x, "spent": y } }
  employeePayroll   Json?           // { "employeeId": { "gross": x, "net": y } }
  monthlyTrends     Json?           // [{ "month": "2025-01", "income": x, "expenses": y }]

  // Generated files
  pdfUrl            String?
  csvUrl            String?
  excelUrl          String?

  // Metadata
  generatedAt       DateTime        @default(now()) @db.Timestamptz(3)
  generatedById     String

  // Relations
  businessAccount   BusinessAccount @relation(fields: [businessAccountId], references: [businessAccountId], onDelete: Cascade)

  @@index([tenantId, businessAccountId])
  @@index([tenantId, businessAccountId, reportType])
  @@index([tenantId, businessAccountId, periodStart, periodEnd])
}

// =============================================================================
// PHASE 4: GOVERNMENT & NOT-FOR-PROFIT ACCOUNTS
// =============================================================================

/// GovernmentAccount: Account for government agencies and departments
model GovernmentAccount {
  governmentAccountId String @id @default(uuid())
  tenantId            String
  orgProfileId        String // Links to OrganizationProfile with entityType=GOVERNMENT
  walletId            String @unique

  // Government-specific fields
  departmentCode      String?          // Government department code
  agencyLevel         GovernmentLevel  @default(LOCAL)
  fiscalYearStart     Int              @default(1)  // Month (1-12)

  // Multi-sig configuration
  defaultRequiredApprovals Int @default(2) // Government typically requires more approvals

  // Audit requirements
  requiresAuditTrail  Boolean @default(true)
  retentionYears      Int     @default(7)   // Document retention period

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  // Relations
  organization     OrganizationProfile     @relation(fields: [orgProfileId], references: [orgProfileId], onDelete: Cascade)
  wallet           Wallet                  @relation(fields: [walletId], references: [walletId])
  signatories      GovernmentSignatory[]
  signatoryRules   GovernmentSignatoryRule[]
  pendingApprovals GovernmentApproval[]
  accountContexts  AccountContext[]
  subAccounts      GovernmentSubAccount[]

  @@unique([tenantId, orgProfileId])
  @@index([tenantId])
  @@index([tenantId, agencyLevel])
}

/// GovernmentLevel: Level of government agency
enum GovernmentLevel {
  FEDERAL
  STATE
  LOCAL
  MUNICIPAL
  SPECIAL_DISTRICT
}

/// GovernmentSignatory: Users who can act on government accounts
model GovernmentSignatory {
  signatoryId         String        @id @default(uuid())
  tenantId            String
  governmentAccountId String
  profileId           String        // Must reference existing UserProfile (personal account)
  role                SignatoryRole

  // Permissions
  canInitiateTransactions Boolean  @default(false)
  canApproveTransactions  Boolean  @default(false)
  maxTransactionLimit     Decimal? @db.Decimal(36, 9)

  // Government-specific
  positionTitle       String?       // Official position/title
  employeeId          String?       // Government employee ID

  // Status
  invitedAt   DateTime  @default(now()) @db.Timestamptz(3)
  confirmedAt DateTime? @db.Timestamptz(3)
  revokedAt   DateTime? @db.Timestamptz(3)

  governmentAccount GovernmentAccount @relation(fields: [governmentAccountId], references: [governmentAccountId], onDelete: Cascade)
  userProfile       UserProfile       @relation(fields: [profileId], references: [profileId], onDelete: Cascade)
  approvalVotes     GovernmentApprovalVote[]

  @@unique([tenantId, governmentAccountId, profileId])
  @@index([tenantId, profileId])
  @@index([tenantId, governmentAccountId])
}

/// GovernmentSignatoryRule: Approval rules for government accounts
model GovernmentSignatoryRule {
  ruleId              String @id @default(uuid())
  tenantId            String
  governmentAccountId String

  // Rule definition
  minAmount         Decimal? @db.Decimal(36, 9)
  maxAmount         Decimal? @db.Decimal(36, 9)
  requiredApprovals Int

  // Optional constraints
  transactionType OffChainTxType?
  dailyLimit      Decimal?        @db.Decimal(36, 9)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  governmentAccount GovernmentAccount @relation(fields: [governmentAccountId], references: [governmentAccountId], onDelete: Cascade)

  @@index([tenantId, governmentAccountId])
  @@index([tenantId, isActive])
}

/// GovernmentApproval: Pending approvals for government transactions
model GovernmentApproval {
  approvalId          String @id @default(uuid())
  tenantId            String
  governmentAccountId String
  outboxCommandId     String

  requiredApprovals Int
  receivedApprovals Int @default(0)

  status    ApprovalStatus @default(PENDING)
  expiresAt DateTime       @db.Timestamptz(3)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  governmentAccount GovernmentAccount        @relation(fields: [governmentAccountId], references: [governmentAccountId], onDelete: Cascade)
  votes             GovernmentApprovalVote[]

  @@index([tenantId, governmentAccountId])
  @@index([tenantId, status])
}

/// GovernmentApprovalVote: Individual votes on government approvals
model GovernmentApprovalVote {
  voteId      String @id @default(uuid())
  tenantId    String
  approvalId  String
  signatoryId String

  approved Boolean
  remarks  String?
  votedAt  DateTime @default(now()) @db.Timestamptz(3)

  approval  GovernmentApproval  @relation(fields: [approvalId], references: [approvalId], onDelete: Cascade)
  signatory GovernmentSignatory @relation(fields: [signatoryId], references: [signatoryId], onDelete: Cascade)

  @@unique([tenantId, approvalId, signatoryId])
  @@index([tenantId, signatoryId])
}

/// GovernmentSubAccount: Budget allocations for government departments
model GovernmentSubAccount {
  id                  String @id @default(uuid())
  tenantId            String
  governmentAccountId String
  name                String
  description         String?
  budgetCode          String?      // Government budget classification code

  // Budget allocation
  allocatedBudget   Decimal @db.Decimal(36, 9)
  currentBalance    Decimal @default(0) @db.Decimal(36, 9)

  // Fiscal period
  fiscalYear        Int
  fiscalPeriod      String?       // Q1, Q2, etc.

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  governmentAccount GovernmentAccount @relation(fields: [governmentAccountId], references: [governmentAccountId], onDelete: Cascade)

  @@unique([tenantId, governmentAccountId, name, fiscalYear])
  @@index([tenantId, governmentAccountId])
}

// =============================================================================
// NOT-FOR-PROFIT ACCOUNTS
// =============================================================================

/// NotForProfitAccount: Account for non-profit organizations and charities
model NotForProfitAccount {
  npoAccountId String @id @default(uuid())
  tenantId     String
  orgProfileId String // Links to OrganizationProfile with entityType=NOT_FOR_PROFIT
  walletId     String @unique

  // NPO-specific fields
  taxExemptStatus     String?           // e.g., "501(c)(3)"
  taxExemptNumber     String?           // Tax exemption registration number
  missionStatement    String?
  category            NPOCategory       @default(OTHER)

  // Compliance
  annualReportDue     DateTime?         @db.Date
  lastAuditDate       DateTime?         @db.Date

  // Multi-sig configuration
  defaultRequiredApprovals Int @default(2)

  // Transparency requirements
  publicDonorList     Boolean @default(false)
  requiresDonorReceipts Boolean @default(true)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  // Relations
  organization     OrganizationProfile   @relation(fields: [orgProfileId], references: [orgProfileId], onDelete: Cascade)
  wallet           Wallet                @relation(fields: [walletId], references: [walletId])
  signatories      NPOSignatory[]
  signatoryRules   NPOSignatoryRule[]
  pendingApprovals NPOApproval[]
  accountContexts  AccountContext[]
  programs         NPOProgram[]
  donations        NPODonation[]

  @@unique([tenantId, orgProfileId])
  @@index([tenantId])
  @@index([tenantId, category])
}

/// NPOCategory: Categories of non-profit organizations
enum NPOCategory {
  CHARITY
  EDUCATION
  HEALTHCARE
  ENVIRONMENTAL
  RELIGIOUS
  ARTS_CULTURE
  HUMANITARIAN
  COMMUNITY
  RESEARCH
  ADVOCACY
  OTHER
}

/// NPOSignatory: Users who can act on NPO accounts
model NPOSignatory {
  signatoryId   String        @id @default(uuid())
  tenantId      String
  npoAccountId  String
  profileId     String        // Must reference existing UserProfile (personal account)
  role          SignatoryRole

  // Permissions
  canInitiateTransactions Boolean  @default(false)
  canApproveTransactions  Boolean  @default(false)
  maxTransactionLimit     Decimal? @db.Decimal(36, 9)

  // NPO-specific
  boardMember     Boolean @default(false)
  volunteerStatus Boolean @default(false)

  // Status
  invitedAt   DateTime  @default(now()) @db.Timestamptz(3)
  confirmedAt DateTime? @db.Timestamptz(3)
  revokedAt   DateTime? @db.Timestamptz(3)

  npoAccount    NotForProfitAccount @relation(fields: [npoAccountId], references: [npoAccountId], onDelete: Cascade)
  userProfile   UserProfile         @relation(fields: [profileId], references: [profileId], onDelete: Cascade)
  approvalVotes NPOApprovalVote[]

  @@unique([tenantId, npoAccountId, profileId])
  @@index([tenantId, profileId])
  @@index([tenantId, npoAccountId])
}

/// NPOSignatoryRule: Approval rules for NPO accounts
model NPOSignatoryRule {
  ruleId       String @id @default(uuid())
  tenantId     String
  npoAccountId String

  minAmount         Decimal? @db.Decimal(36, 9)
  maxAmount         Decimal? @db.Decimal(36, 9)
  requiredApprovals Int

  transactionType OffChainTxType?
  dailyLimit      Decimal?        @db.Decimal(36, 9)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  npoAccount NotForProfitAccount @relation(fields: [npoAccountId], references: [npoAccountId], onDelete: Cascade)

  @@index([tenantId, npoAccountId])
  @@index([tenantId, isActive])
}

/// NPOApproval: Pending approvals for NPO transactions
model NPOApproval {
  approvalId      String @id @default(uuid())
  tenantId        String
  npoAccountId    String
  outboxCommandId String

  requiredApprovals Int
  receivedApprovals Int @default(0)

  status    ApprovalStatus @default(PENDING)
  expiresAt DateTime       @db.Timestamptz(3)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  npoAccount NotForProfitAccount @relation(fields: [npoAccountId], references: [npoAccountId], onDelete: Cascade)
  votes      NPOApprovalVote[]

  @@index([tenantId, npoAccountId])
  @@index([tenantId, status])
}

/// NPOApprovalVote: Individual votes on NPO approvals
model NPOApprovalVote {
  voteId      String @id @default(uuid())
  tenantId    String
  approvalId  String
  signatoryId String

  approved Boolean
  remarks  String?
  votedAt  DateTime @default(now()) @db.Timestamptz(3)

  approval  NPOApproval  @relation(fields: [approvalId], references: [approvalId], onDelete: Cascade)
  signatory NPOSignatory @relation(fields: [signatoryId], references: [signatoryId], onDelete: Cascade)

  @@unique([tenantId, approvalId, signatoryId])
  @@index([tenantId, signatoryId])
}

/// NPOProgram: Programs/projects run by NPOs for fund allocation
model NPOProgram {
  programId    String @id @default(uuid())
  tenantId     String
  npoAccountId String
  name         String
  description  String?

  // Budget
  budgetAmount    Decimal  @db.Decimal(36, 9)
  spentAmount     Decimal  @default(0) @db.Decimal(36, 9)
  remainingAmount Decimal  @db.Decimal(36, 9)

  // Timeline
  startDate   DateTime  @db.Date
  endDate     DateTime? @db.Date

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  npoAccount NotForProfitAccount @relation(fields: [npoAccountId], references: [npoAccountId], onDelete: Cascade)

  @@unique([tenantId, npoAccountId, name])
  @@index([tenantId, npoAccountId])
}

/// NPODonation: Track donations received by NPOs
model NPODonation {
  donationId   String @id @default(uuid())
  tenantId     String
  npoAccountId String

  // Donor info (can be anonymous)
  donorProfileId String?       // If donor has GX account
  donorName      String?       // For external/anonymous donors
  isAnonymous    Boolean       @default(false)

  // Donation details
  amount       Decimal  @db.Decimal(36, 9)
  currency     String   @default("GXC")
  transactionId String? // GX Transaction ID

  // Tax receipt
  receiptIssued   Boolean   @default(false)
  receiptNumber   String?
  receiptIssuedAt DateTime? @db.Timestamptz(3)

  // Purpose
  programId     String?       // If designated for specific program
  designation   String?       // e.g., "General Fund", "Building Fund"

  createdAt DateTime @default(now()) @db.Timestamptz(3)

  npoAccount   NotForProfitAccount @relation(fields: [npoAccountId], references: [npoAccountId], onDelete: Cascade)
  donorProfile UserProfile?        @relation(fields: [donorProfileId], references: [profileId])

  @@index([tenantId, npoAccountId])
  @@index([tenantId, donorProfileId])
  @@index([tenantId, createdAt])
}

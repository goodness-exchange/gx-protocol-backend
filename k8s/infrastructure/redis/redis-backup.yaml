---
# ConfigMap for Redis backup scripts
apiVersion: v1
kind: ConfigMap
metadata:
  name: redis-backup-scripts
  namespace: backend-mainnet
data:
  backup.sh: |
    #!/bin/bash
    set -e

    TIMESTAMP=$(date +%Y%m%d-%H%M%S)
    BACKUP_DIR="/backups"
    RDB_BACKUP="$BACKUP_DIR/redis-dump-$TIMESTAMP.rdb"
    AOF_BACKUP="$BACKUP_DIR/redis-aof-$TIMESTAMP.aof"

    echo "Starting Redis backup at $TIMESTAMP"

    # Create backup directory
    mkdir -p $BACKUP_DIR

    # Trigger BGSAVE on master to create RDB snapshot
    echo "Triggering RDB snapshot..."
    redis-cli -h redis-0.redis-headless -a "$REDIS_PASSWORD" BGSAVE

    # Wait for BGSAVE to complete
    while [ "$(redis-cli -h redis-0.redis-headless -a "$REDIS_PASSWORD" LASTSAVE)" == "$LAST_SAVE" ]; do
      echo "Waiting for BGSAVE to complete..."
      sleep 2
    done

    echo "RDB snapshot completed"

    # Copy RDB file from master pod
    kubectl cp -n backend-mainnet redis-0:/data/dump.rdb "$RDB_BACKUP" || echo "RDB copy failed"

    # Copy AOF file from master pod
    kubectl cp -n backend-mainnet redis-0:/data/appendonly.aof "$AOF_BACKUP" || echo "AOF copy failed"

    echo "Backup files created:"
    ls -lh "$RDB_BACKUP" "$AOF_BACKUP" 2>/dev/null || echo "Some backups missing"

    # Compress backups
    gzip -f "$RDB_BACKUP" 2>/dev/null && echo "RDB compressed"
    gzip -f "$AOF_BACKUP" 2>/dev/null && echo "AOF compressed"

    # Keep only last 30 backups
    cd $BACKUP_DIR
    ls -t redis-dump-*.rdb.gz 2>/dev/null | tail -n +31 | xargs -r rm
    ls -t redis-aof-*.aof.gz 2>/dev/null | tail -n +31 | xargs -r rm
    echo "Old backups cleaned up"

    # List remaining backups
    echo "Current backups:"
    ls -lh redis-* 2>/dev/null || echo "No backups found"

    # TODO: Upload to object storage (S3/MinIO)
    # aws s3 cp "$RDB_BACKUP.gz" s3://gx-backups/redis/ || echo "S3 upload failed"

    echo "Redis backup process completed successfully"

  restore.sh: |
    #!/bin/bash
    set -e

    if [ -z "$1" ]; then
      echo "Usage: $0 <backup-file>"
      echo "Available backups:"
      ls -lh /backups/redis-* 2>/dev/null || echo "No backups found"
      exit 1
    fi

    BACKUP_FILE="$1"
    BACKUP_TYPE="${BACKUP_FILE##*.}"

    echo "Restoring Redis from: $BACKUP_FILE"

    # Stop Redis on all pods
    echo "Stopping Redis on all pods..."
    for i in 0 1 2; do
      kubectl exec -n backend-mainnet redis-$i -- redis-cli -a "$REDIS_PASSWORD" SHUTDOWN SAVE 2>/dev/null || echo "redis-$i already stopped"
    done

    sleep 5

    # Decompress backup if needed
    if [[ "$BACKUP_FILE" == *.gz ]]; then
      echo "Decompressing backup..."
      gunzip -c "$BACKUP_FILE" > /tmp/restore-file
      RESTORE_FILE="/tmp/restore-file"
    else
      RESTORE_FILE="$BACKUP_FILE"
    fi

    # Copy backup to master pod
    echo "Copying backup to redis-0..."
    if [[ "$BACKUP_TYPE" == "rdb" || "$BACKUP_TYPE" == "gz" ]]; then
      kubectl cp "$RESTORE_FILE" backend-mainnet/redis-0:/data/dump.rdb
    elif [[ "$BACKUP_TYPE" == "aof" ]]; then
      kubectl cp "$RESTORE_FILE" backend-mainnet/redis-0:/data/appendonly.aof
    fi

    # Restart Redis pods
    echo "Restarting Redis StatefulSet..."
    kubectl rollout restart statefulset/redis -n backend-mainnet

    echo "Waiting for Redis to be ready..."
    kubectl rollout status statefulset/redis -n backend-mainnet

    echo "Redis restore completed successfully"
    echo "Verifying keys count..."
    redis-cli -h redis-master -a "$REDIS_PASSWORD" DBSIZE

---
# CronJob for automated Redis backups
apiVersion: batch/v1
kind: CronJob
metadata:
  name: redis-backup
  namespace: backend-mainnet
  labels:
    app: redis
    component: backup
spec:
  # Run every 6 hours (at 00:00, 06:00, 12:00, 18:00 UTC)
  schedule: "0 */6 * * *"
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  concurrencyPolicy: Forbid

  jobTemplate:
    metadata:
      labels:
        app: redis-backup
        component: backup
    spec:
      template:
        metadata:
          labels:
            app: redis-backup
        spec:
          restartPolicy: OnFailure
          serviceAccountName: redis-backup-sa
          securityContext:
            runAsUser: 999
            runAsNonRoot: true
            fsGroup: 999

          containers:
          - name: redis-backup
            image: redis:7-alpine
            command:
            - /bin/sh
            - /scripts/backup.sh

            env:
            - name: REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: redis-credentials
                  key: REDIS_PASSWORD

            volumeMounts:
            - name: backup-scripts
              mountPath: /scripts
            - name: backup-storage
              mountPath: /backups

            resources:
              requests:
                cpu: "100m"
                memory: "128Mi"
              limits:
                cpu: "200m"
                memory: "256Mi"

          volumes:
          - name: backup-scripts
            configMap:
              name: redis-backup-scripts
              defaultMode: 0755
          - name: backup-storage
            persistentVolumeClaim:
              claimName: redis-backup-pvc

---
# PVC for Redis backup storage
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: redis-backup-pvc
  namespace: backend-mainnet
  labels:
    app: redis
    component: backup
spec:
  accessModes:
  - ReadWriteOnce
  storageClassName: local-path
  resources:
    requests:
      storage: 20Gi  # Store ~30 backups

---
# ServiceAccount for backup job (needs kubectl access)
apiVersion: v1
kind: ServiceAccount
metadata:
  name: redis-backup-sa
  namespace: backend-mainnet
  labels:
    app: redis
    component: backup

---
# Role for backup job to access Redis pods
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: redis-backup-role
  namespace: backend-mainnet
rules:
- apiGroups: [""]
  resources: ["pods", "pods/exec"]
  verbs: ["get", "list", "create"]
- apiGroups: [""]
  resources: ["pods/log"]
  verbs: ["get"]

---
# RoleBinding for backup ServiceAccount
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: redis-backup-rolebinding
  namespace: backend-mainnet
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: redis-backup-role
subjects:
- kind: ServiceAccount
  name: redis-backup-sa
  namespace: backend-mainnet

---
# Manual backup job (can be triggered on-demand)
apiVersion: batch/v1
kind: Job
metadata:
  name: redis-manual-backup
  namespace: backend-mainnet
  labels:
    app: redis
    component: backup
    type: manual
spec:
  template:
    metadata:
      labels:
        app: redis-backup
    spec:
      restartPolicy: Never
      serviceAccountName: redis-backup-sa
      containers:
      - name: redis-backup
        image: redis:7-alpine
        command:
        - /bin/sh
        - /scripts/backup.sh
        env:
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: redis-credentials
              key: REDIS_PASSWORD
        volumeMounts:
        - name: backup-scripts
          mountPath: /scripts
        - name: backup-storage
          mountPath: /backups
      volumes:
      - name: backup-scripts
        configMap:
          name: redis-backup-scripts
          defaultMode: 0755
      - name: backup-storage
        persistentVolumeClaim:
          claimName: redis-backup-pvc
